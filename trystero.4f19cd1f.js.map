{"mappings":"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C,IAAI,WAAW,KAEjD,OACE,EAAG,IAAI,CANQ,KADF,IASb,EACE,MAAM,OAAO,MAAM,CAAC,OAAO,CACzB,CAAC,KAAM,EAAM,GAAA,CAAE,EACf,MAAM,EACN,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EAAY,IAIpB,EAEa,EAAU,MAAO,EAAM,KAClC,GAAM,CAAC,EAAI,EAAE,CAAG,EAAI,KAAK,CApBV,KAsBf,MAAO,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EACL,MAAM,OAAO,MAAM,CAAC,OAAO,CACzB,CAAC,KAAM,EAAM,GAAI,IAAI,WAAW,EAAG,KAAK,CAvB3B,KAuBwC,EACrD,MAAM,EACN,EAAO,IAGb,C,G,E,Q,S,C,C,C,E,E,E,O,C,U,W,O,C,G,E,E,O,C,Q,W,O,C,G,E,E,O,C,Q,W,O,C,G,E,E,O,C,S,W,O,C,G,E,E,O,C,M,W,O,C,G,E,E,O,C,Y,W,O,C,G,E,E,O,C,U,W,O,C,G,E,E,O,C,c,W,O,C,G,E,E,O,C,O,W,O,C,G,E,E,O,C,O,W,O,C,G,E,E,O,C,Q,W,O,C,G,E,E,O,C,c,W,O,C,G,E,E,O,C,c,W,O,C,G,E,E,O,C,Q,W,O,C,G,E,E,O,C,Y,W,O,C,G,E,E,O,C,Y,W,O,C,G,E,E,O,C,S,W,O,C,G,E,E,O,C,W,W,O,C,G,E,E,O,C,a,W,O,C,G,E,E,O,C,e,W,O,C,GCvEO,IAAM,EAAU,WAEV,EAAQ,CAAC,EAAG,IAAM,MAAM,GAAG,IAAI,GAAG,GAAG,CAAC,GAE7C,EAAU,iEAEH,EAAQ,AAAA,GACnB,EAAM,EAAG,IAAM,CAAO,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAQ,MAAM,EAAE,EAAE,IAAI,CAAC,IAE9D,EAAS,EAAM,IAEf,EAAM,QAAQ,GAAG,CAAC,IAAI,CAAC,SAEvB,EAAY,AAAkB,aAAlB,OAAO,OAEnB,CAAA,QAAC,CAAO,CAAA,YAAE,CAAW,CAAA,KAAE,CAAI,CAAC,CAAG,OAE/B,EAAO,KAAO,EAEd,EAAQ,AAAA,GAAO,AAAI,MAAM,CAAA,EAAG,EAAQ,EAAE,EAAE,EAAA,CAAK,EAEpD,EAAU,IAAI,YACd,EAAU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","sources":["<anon>","node_modules/trystero/src/index.js","node_modules/trystero/src/nostr.js","node_modules/@noble/curves/secp256k1.js","node_modules/@noble/curves/src/secp256k1.ts","node_modules/@noble/hashes/sha256.js","node_modules/@noble/hashes/src/sha256.ts","node_modules/@noble/hashes/_md.js","node_modules/@noble/hashes/src/_md.ts","node_modules/@noble/hashes/_assert.js","node_modules/@noble/hashes/src/_assert.ts","node_modules/@noble/hashes/utils.js","node_modules/@noble/hashes/src/utils.ts","node_modules/@noble/hashes/crypto.js","node_modules/@noble/hashes/src/crypto.ts","node_modules/@noble/curves/_shortw_utils.js","node_modules/@noble/curves/src/_shortw_utils.ts","node_modules/@noble/hashes/hmac.js","node_modules/@noble/hashes/src/hmac.ts","node_modules/@noble/curves/abstract/weierstrass.js","node_modules/@noble/curves/src/abstract/weierstrass.ts","node_modules/@noble/curves/abstract/curve.js","node_modules/@noble/curves/src/abstract/curve.ts","node_modules/@noble/curves/abstract/modular.js","node_modules/@noble/curves/src/abstract/modular.ts","node_modules/@noble/curves/abstract/utils.js","node_modules/@noble/curves/src/abstract/utils.ts","node_modules/@noble/curves/abstract/hash-to-curve.js","node_modules/@noble/curves/src/abstract/hash-to-curve.ts","node_modules/trystero/src/strategy.js","node_modules/trystero/src/crypto.js","node_modules/trystero/src/utils.js","node_modules/trystero/src/peer.js","node_modules/@thaunknown/simple-peer/index.js","node_modules/@thaunknown/simple-peer/lite.js","node_modules/@thaunknown/simple-peer/node_modules/debug/src/browser.js","node_modules/process/browser.js","node_modules/@thaunknown/simple-peer/node_modules/debug/src/common.js","node_modules/@thaunknown/simple-peer/node_modules/ms/index.js","node_modules/webrtc-polyfill/browser.js","node_modules/streamx/index.js","node_modules/events/events.js","node_modules/queue-tick/queue-microtask.js","node_modules/fast-fifo/index.js","node_modules/fast-fifo/fixed-size.js","node_modules/text-decoder/index.js","node_modules/text-decoder/lib/browser-decoder.js","node_modules/err-code/index.js","node_modules/uint8-util/browser.js","node_modules/uint8-util/util.js","node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","node_modules/src/index.ts","node_modules/trystero/src/room.js"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9a6Ck\", function(module, exports) {\n\n$parcel$export(module.exports, \"joinRoom\", function () { return (parcelRequire(\"evcPq\")).joinRoom; });\n\nvar $evcPq = parcelRequire(\"evcPq\");\n\n});\nparcelRegister(\"evcPq\", function(module, exports) {\n\n$parcel$export(module.exports, \"joinRoom\", function () { return $a8ede964070fd1a8$export$767472c72ffc2784; });\n\nvar $7vd9o = parcelRequire(\"7vd9o\");\n\nvar $eLZBv = parcelRequire(\"eLZBv\");\n\nvar $cQlYm = parcelRequire(\"cQlYm\");\nconst $a8ede964070fd1a8$var$clients = {};\nconst $a8ede964070fd1a8$var$defaultRedundancy = 5;\nconst $a8ede964070fd1a8$var$kind = 29333;\nconst $a8ede964070fd1a8$var$tag = 'x';\nconst $a8ede964070fd1a8$var$eventMsgType = 'EVENT';\nconst $a8ede964070fd1a8$var$privateKey = (0, $cQlYm.isBrowser) && (0, $7vd9o.schnorr).utils.randomPrivateKey();\nconst $a8ede964070fd1a8$var$publicKey = (0, $cQlYm.isBrowser) && (0, $cQlYm.toHex)((0, $7vd9o.schnorr).getPublicKey($a8ede964070fd1a8$var$privateKey));\nconst $a8ede964070fd1a8$var$subIdToTopic = {};\nconst $a8ede964070fd1a8$var$msgHandlers = {};\nconst $a8ede964070fd1a8$var$now = ()=>Math.floor(Date.now() / 1000);\nconst $a8ede964070fd1a8$var$createEvent = async (topic, content)=>{\n    const payload = {\n        kind: $a8ede964070fd1a8$var$kind,\n        content: content,\n        pubkey: $a8ede964070fd1a8$var$publicKey,\n        created_at: $a8ede964070fd1a8$var$now(),\n        tags: [\n            [\n                $a8ede964070fd1a8$var$tag,\n                topic\n            ]\n        ]\n    };\n    const id = (0, $cQlYm.toHex)(new Uint8Array(await crypto.subtle.digest('SHA-256', (0, $cQlYm.encodeBytes)((0, $cQlYm.toJson)([\n        0,\n        payload.pubkey,\n        payload.created_at,\n        payload.kind,\n        payload.tags,\n        payload.content\n    ])))));\n    return (0, $cQlYm.toJson)([\n        $a8ede964070fd1a8$var$eventMsgType,\n        {\n            ...payload,\n            id: id,\n            sig: (0, $cQlYm.toHex)(await (0, $7vd9o.schnorr).sign(id, $a8ede964070fd1a8$var$privateKey))\n        }\n    ]);\n};\nconst $a8ede964070fd1a8$var$subscribe = (subId, topic)=>{\n    $a8ede964070fd1a8$var$subIdToTopic[subId] = topic;\n    return (0, $cQlYm.toJson)([\n        'REQ',\n        subId,\n        {\n            kinds: [\n                $a8ede964070fd1a8$var$kind\n            ],\n            since: $a8ede964070fd1a8$var$now(),\n            ['#' + $a8ede964070fd1a8$var$tag]: [\n                topic\n            ]\n        }\n    ]);\n};\nconst $a8ede964070fd1a8$var$unsubscribe = (subId)=>{\n    delete $a8ede964070fd1a8$var$subIdToTopic[subId];\n    return (0, $cQlYm.toJson)([\n        'CLOSE',\n        subId\n    ]);\n};\nconst $a8ede964070fd1a8$export$767472c72ffc2784 = (0, $eLZBv.default)({\n    init: (config)=>(0, $cQlYm.getRelays)(config, $a8ede964070fd1a8$export$2e74fe4648f5c212, $a8ede964070fd1a8$var$defaultRedundancy).map((url)=>{\n            const client = (0, $cQlYm.makeSocket)(url, (data)=>{\n                const [msgType, subId, payload, relayMsg] = (0, $cQlYm.fromJson)(data);\n                if (msgType !== $a8ede964070fd1a8$var$eventMsgType) {\n                    const prefix = `${(0, $cQlYm.libName)}: relay failure from ${client.url} - `;\n                    if (msgType === 'NOTICE') console.warn(prefix + subId);\n                    else if (msgType === 'OK' && !payload) console.warn(prefix + relayMsg);\n                    return;\n                }\n                $a8ede964070fd1a8$var$msgHandlers[subId]?.($a8ede964070fd1a8$var$subIdToTopic[subId], payload.content);\n            });\n            $a8ede964070fd1a8$var$clients[url] = client;\n            return client.ready;\n        }),\n    subscribe: (client, rootTopic, selfTopic, onMessage)=>{\n        const rootSubId = (0, $cQlYm.genId)(64);\n        const selfSubId = (0, $cQlYm.genId)(64);\n        $a8ede964070fd1a8$var$msgHandlers[rootSubId] = $a8ede964070fd1a8$var$msgHandlers[selfSubId] = (topic, data)=>onMessage(topic, data, async (peerTopic, signal)=>client.send(await $a8ede964070fd1a8$var$createEvent(peerTopic, signal)));\n        client.send($a8ede964070fd1a8$var$subscribe(rootSubId, rootTopic));\n        client.send($a8ede964070fd1a8$var$subscribe(selfSubId, selfTopic));\n        return ()=>{\n            client.send($a8ede964070fd1a8$var$unsubscribe(rootSubId));\n            client.send($a8ede964070fd1a8$var$unsubscribe(selfSubId));\n            delete $a8ede964070fd1a8$var$msgHandlers[rootSubId];\n            delete $a8ede964070fd1a8$var$msgHandlers[selfSubId];\n        };\n    },\n    announce: async (client, rootTopic)=>client.send(await $a8ede964070fd1a8$var$createEvent(rootTopic, (0, $cQlYm.toJson)({\n            peerId: (0, $cQlYm.selfId)\n        })))\n});\nconst $a8ede964070fd1a8$export$21c289fa8cb92650 = (0, $cQlYm.socketGetter)($a8ede964070fd1a8$var$clients);\nconst $a8ede964070fd1a8$export$2e74fe4648f5c212 = [\n    'relay.nostr.net',\n    'relay.snort.social',\n    'relay.piazza.today',\n    'relay.exit.pub',\n    'nostr.lu.ke',\n    'nostr.mom',\n    'relay.urbanzap.space',\n    'nostr.data.haus',\n    'nostr.sathoarder.com',\n    'relay.nostromo.social',\n    'relay.nostr.bg',\n    'nostr.stakey.net',\n    'nostr.vulpem.com',\n    'a.nos.lol',\n    'eu.purplerelay.com',\n    'nostr2.sanhauf.com',\n    'e.nos.lol'\n].map((url)=>'wss://' + url);\n\n});\nparcelRegister(\"7vd9o\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.encodeToCurve = module.exports.hashToCurve = module.exports.schnorr = module.exports.secp256k1 = void 0;\n\nvar $5x5A6 = parcelRequire(\"5x5A6\");\n\nvar $9YMwy = parcelRequire(\"9YMwy\");\n\nvar $2kyNN = parcelRequire(\"2kyNN\");\n\nvar $57dpp = parcelRequire(\"57dpp\");\n\nvar $i945l = parcelRequire(\"i945l\");\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\n\nvar $7lNi7 = parcelRequire(\"7lNi7\");\nconst $5765a1182d26d576$var$secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst $5765a1182d26d576$var$secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst $5765a1182d26d576$var$_1n = BigInt(1);\nconst $5765a1182d26d576$var$_2n = BigInt(2);\nconst $5765a1182d26d576$var$divNearest = (a, b)=>(a + b / $5765a1182d26d576$var$_2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function $5765a1182d26d576$var$sqrtMod(y) {\n    const P = $5765a1182d26d576$var$secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, $i945l.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, $i945l.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, $i945l.pow2)(b9, $5765a1182d26d576$var$_2n, P) * b2 % P;\n    const b22 = (0, $i945l.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, $i945l.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, $i945l.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, $i945l.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, $i945l.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, $i945l.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, $i945l.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, $i945l.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, $i945l.pow2)(t2, $5765a1182d26d576$var$_2n, P);\n    if (!$5765a1182d26d576$var$Fpk1.eql($5765a1182d26d576$var$Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n    return root;\n}\nconst $5765a1182d26d576$var$Fpk1 = (0, $i945l.Field)($5765a1182d26d576$var$secp256k1P, undefined, undefined, {\n    sqrt: $5765a1182d26d576$var$sqrtMod\n});\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n */ module.exports.secp256k1 = (0, $2kyNN.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp: $5765a1182d26d576$var$Fpk1,\n    n: $5765a1182d26d576$var$secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k)=>{\n            const n = $5765a1182d26d576$var$secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -$5765a1182d26d576$var$_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = $5765a1182d26d576$var$divNearest(b2 * k, n);\n            const c2 = $5765a1182d26d576$var$divNearest(-b1 * k, n);\n            let k1 = (0, $i945l.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, $i945l.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            return {\n                k1neg: k1neg,\n                k1: k1,\n                k2neg: k2neg,\n                k2: k2\n            };\n        }\n    }\n}, $5x5A6.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst $5765a1182d26d576$var$_0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const $5765a1182d26d576$var$TAGGED_HASH_PREFIXES = {};\nfunction $5765a1182d26d576$var$taggedHash(tag, ...messages) {\n    let tagP = $5765a1182d26d576$var$TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, $5x5A6.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, $1GzxI.concatBytes)(tagH, tagH);\n        $5765a1182d26d576$var$TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, $5x5A6.sha256)((0, $1GzxI.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst $5765a1182d26d576$var$pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst $5765a1182d26d576$var$numTo32b = (n)=>(0, $1GzxI.numberToBytesBE)(n, 32);\nconst $5765a1182d26d576$var$modP = (x)=>(0, $i945l.mod)(x, $5765a1182d26d576$var$secp256k1P);\nconst $5765a1182d26d576$var$modN = (x)=>(0, $i945l.mod)(x, $5765a1182d26d576$var$secp256k1N);\nconst $5765a1182d26d576$var$Point = module.exports.secp256k1.ProjectivePoint;\nconst $5765a1182d26d576$var$GmulAdd = (Q, a, b)=>$5765a1182d26d576$var$Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction $5765a1182d26d576$var$schnorrGetExtPubKey(priv) {\n    let d_ = module.exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = $5765a1182d26d576$var$Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : $5765a1182d26d576$var$modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: $5765a1182d26d576$var$pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function $5765a1182d26d576$var$lift_x(x) {\n    (0, $1GzxI.aInRange)('x', x, $5765a1182d26d576$var$_1n, $5765a1182d26d576$var$secp256k1P); // Fail if x ≥ p.\n    const xx = $5765a1182d26d576$var$modP(x * x);\n    const c = $5765a1182d26d576$var$modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = $5765a1182d26d576$var$sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % $5765a1182d26d576$var$_2n !== $5765a1182d26d576$var$_0n) y = $5765a1182d26d576$var$modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new $5765a1182d26d576$var$Point(x, y, $5765a1182d26d576$var$_1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst $5765a1182d26d576$var$num = $1GzxI.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function $5765a1182d26d576$var$challenge(...args) {\n    return $5765a1182d26d576$var$modN($5765a1182d26d576$var$num($5765a1182d26d576$var$taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function $5765a1182d26d576$var$schnorrGetPublicKey(privateKey) {\n    return $5765a1182d26d576$var$schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function $5765a1182d26d576$var$schnorrSign(message, privateKey, auxRand = (0, $9YMwy.randomBytes)(32)) {\n    const m = (0, $1GzxI.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = $5765a1182d26d576$var$schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, $1GzxI.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = $5765a1182d26d576$var$numTo32b(d ^ $5765a1182d26d576$var$num($5765a1182d26d576$var$taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = $5765a1182d26d576$var$taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = $5765a1182d26d576$var$modN($5765a1182d26d576$var$num(rand)); // Let k' = int(rand) mod n\n    if (k_ === $5765a1182d26d576$var$_0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = $5765a1182d26d576$var$schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = $5765a1182d26d576$var$challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set($5765a1182d26d576$var$numTo32b($5765a1182d26d576$var$modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!$5765a1182d26d576$var$schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function $5765a1182d26d576$var$schnorrVerify(signature, message, publicKey) {\n    const sig = (0, $1GzxI.ensureBytes)('signature', signature, 64);\n    const m = (0, $1GzxI.ensureBytes)('message', message);\n    const pub = (0, $1GzxI.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = $5765a1182d26d576$var$lift_x($5765a1182d26d576$var$num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = $5765a1182d26d576$var$num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0, $1GzxI.inRange)(r, $5765a1182d26d576$var$_1n, $5765a1182d26d576$var$secp256k1P)) return false;\n        const s = $5765a1182d26d576$var$num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0, $1GzxI.inRange)(s, $5765a1182d26d576$var$_1n, $5765a1182d26d576$var$secp256k1N)) return false;\n        const e = $5765a1182d26d576$var$challenge($5765a1182d26d576$var$numTo32b(r), $5765a1182d26d576$var$pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = $5765a1182d26d576$var$GmulAdd(P, s, $5765a1182d26d576$var$modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n */ module.exports.schnorr = (()=>({\n        getPublicKey: $5765a1182d26d576$var$schnorrGetPublicKey,\n        sign: $5765a1182d26d576$var$schnorrSign,\n        verify: $5765a1182d26d576$var$schnorrVerify,\n        utils: {\n            randomPrivateKey: module.exports.secp256k1.utils.randomPrivateKey,\n            lift_x: $5765a1182d26d576$var$lift_x,\n            pointToBytes: $5765a1182d26d576$var$pointToBytes,\n            numberToBytesBE: $1GzxI.numberToBytesBE,\n            bytesToNumberBE: $1GzxI.bytesToNumberBE,\n            taggedHash: $5765a1182d26d576$var$taggedHash,\n            mod: $i945l.mod\n        }\n    }))();\nconst $5765a1182d26d576$var$isoMap = /* @__PURE__ */ (()=>(0, $57dpp.isogenyMap)($5765a1182d26d576$var$Fpk1, [\n        // xNum\n        [\n            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'\n        ],\n        // xDen\n        [\n            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n            '0x0000000000000000000000000000000000000000000000000000000000000001'\n        ],\n        // yNum\n        [\n            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'\n        ],\n        // yDen\n        [\n            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n            '0x0000000000000000000000000000000000000000000000000000000000000001'\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst $5765a1182d26d576$var$mapSWU = /* @__PURE__ */ (()=>(0, $7lNi7.mapToCurveSimpleSWU)($5765a1182d26d576$var$Fpk1, {\n        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n        B: BigInt('1771'),\n        Z: $5765a1182d26d576$var$Fpk1.create(BigInt('-11'))\n    }))();\nconst $5765a1182d26d576$var$htf = /* @__PURE__ */ (()=>(0, $57dpp.createHasher)(module.exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x: x, y: y } = $5765a1182d26d576$var$mapSWU($5765a1182d26d576$var$Fpk1.create(scalars[0]));\n        return $5765a1182d26d576$var$isoMap(x, y);\n    }, {\n        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n        p: $5765a1182d26d576$var$Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: 'xmd',\n        hash: $5x5A6.sha256\n    }))();\nmodule.exports.hashToCurve = (()=>$5765a1182d26d576$var$htf.hashToCurve)();\nmodule.exports.encodeToCurve = (()=>$5765a1182d26d576$var$htf.encodeToCurve)();\n\n});\nparcelRegister(\"5x5A6\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.sha224 = module.exports.sha256 = module.exports.SHA256 = void 0;\n\nvar $jC5k4 = parcelRequire(\"jC5k4\");\n\nvar $9YMwy = parcelRequire(\"9YMwy\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst $40745d2159d0279c$var$SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst $40745d2159d0279c$var$SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst $40745d2159d0279c$var$SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass $40745d2159d0279c$var$SHA256 extends $jC5k4.HashMD {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = $40745d2159d0279c$var$SHA256_IV[0] | 0;\n        this.B = $40745d2159d0279c$var$SHA256_IV[1] | 0;\n        this.C = $40745d2159d0279c$var$SHA256_IV[2] | 0;\n        this.D = $40745d2159d0279c$var$SHA256_IV[3] | 0;\n        this.E = $40745d2159d0279c$var$SHA256_IV[4] | 0;\n        this.F = $40745d2159d0279c$var$SHA256_IV[5] | 0;\n        this.G = $40745d2159d0279c$var$SHA256_IV[6] | 0;\n        this.H = $40745d2159d0279c$var$SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)$40745d2159d0279c$var$SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = $40745d2159d0279c$var$SHA256_W[i - 15];\n            const W2 = $40745d2159d0279c$var$SHA256_W[i - 2];\n            const s0 = (0, $9YMwy.rotr)(W15, 7) ^ (0, $9YMwy.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, $9YMwy.rotr)(W2, 17) ^ (0, $9YMwy.rotr)(W2, 19) ^ W2 >>> 10;\n            $40745d2159d0279c$var$SHA256_W[i] = s1 + $40745d2159d0279c$var$SHA256_W[i - 7] + s0 + $40745d2159d0279c$var$SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, $9YMwy.rotr)(E, 6) ^ (0, $9YMwy.rotr)(E, 11) ^ (0, $9YMwy.rotr)(E, 25);\n            const T1 = H + sigma1 + (0, $jC5k4.Chi)(E, F, G) + $40745d2159d0279c$var$SHA256_K[i] + $40745d2159d0279c$var$SHA256_W[i] | 0;\n            const sigma0 = (0, $9YMwy.rotr)(A, 2) ^ (0, $9YMwy.rotr)(A, 13) ^ (0, $9YMwy.rotr)(A, 22);\n            const T2 = sigma0 + (0, $jC5k4.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        $40745d2159d0279c$var$SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nmodule.exports.SHA256 = $40745d2159d0279c$var$SHA256;\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass $40745d2159d0279c$var$SHA224 extends $40745d2159d0279c$var$SHA256 {\n    constructor(){\n        super();\n        this.A = -1056596264;\n        this.B = 914150663;\n        this.C = 812702999;\n        this.D = -150054599;\n        this.E = -4191439;\n        this.F = 1750603025;\n        this.G = 1694076839;\n        this.H = -1090891868;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ module.exports.sha256 = (0, $9YMwy.wrapConstructor)(()=>new $40745d2159d0279c$var$SHA256());\n/**\n * SHA2-224 hash function\n */ module.exports.sha224 = (0, $9YMwy.wrapConstructor)(()=>new $40745d2159d0279c$var$SHA224());\n\n});\nparcelRegister(\"jC5k4\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.HashMD = module.exports.Maj = module.exports.Chi = void 0;\n\nvar $1BNC9 = parcelRequire(\"1BNC9\");\n\nvar $9YMwy = parcelRequire(\"9YMwy\");\n/**\n * Polyfill for Safari 14\n */ function $e475b1ec6dc1b20c$var$setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */ const $e475b1ec6dc1b20c$var$Chi = (a, b, c)=>a & b ^ ~a & c;\nmodule.exports.Chi = $e475b1ec6dc1b20c$var$Chi;\n/**\n * Majority function, true if any two inputs is true\n */ const $e475b1ec6dc1b20c$var$Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\nmodule.exports.Maj = $e475b1ec6dc1b20c$var$Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class $e475b1ec6dc1b20c$var$HashMD extends $9YMwy.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, $9YMwy.createView)(this.buffer);\n    }\n    update(data) {\n        (0, $1BNC9.aexists)(this);\n        const { view: view, buffer: buffer, blockLen: blockLen } = this;\n        data = (0, $9YMwy.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, $9YMwy.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, $1BNC9.aexists)(this);\n        (0, $1BNC9.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer: buffer, view: view, blockLen: blockLen, isLE: isLE } = this;\n        let { pos: pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        $e475b1ec6dc1b20c$var$setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, $9YMwy.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer: buffer, outputLen: outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen: blockLen, buffer: buffer, length: length, finished: finished, destroyed: destroyed, pos: pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nmodule.exports.HashMD = $e475b1ec6dc1b20c$var$HashMD;\n\n});\nparcelRegister(\"1BNC9\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.anumber = $12bfbb86ba5aff13$var$anumber;\nmodule.exports.number = $12bfbb86ba5aff13$var$anumber;\nmodule.exports.abytes = $12bfbb86ba5aff13$var$abytes;\nmodule.exports.bytes = $12bfbb86ba5aff13$var$abytes;\nmodule.exports.ahash = $12bfbb86ba5aff13$var$ahash;\nmodule.exports.aexists = $12bfbb86ba5aff13$var$aexists;\nmodule.exports.aoutput = $12bfbb86ba5aff13$var$aoutput;\nfunction $12bfbb86ba5aff13$var$anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction $12bfbb86ba5aff13$var$isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\nfunction $12bfbb86ba5aff13$var$abytes(b, ...lengths) {\n    if (!$12bfbb86ba5aff13$var$isBytes(b)) throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction $12bfbb86ba5aff13$var$ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    $12bfbb86ba5aff13$var$anumber(h.outputLen);\n    $12bfbb86ba5aff13$var$anumber(h.blockLen);\n}\nfunction $12bfbb86ba5aff13$var$aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction $12bfbb86ba5aff13$var$aoutput(out, instance) {\n    $12bfbb86ba5aff13$var$abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) throw new Error('digestInto() expects output buffer of length at least ' + min);\n}\nconst $12bfbb86ba5aff13$var$assert = {\n    number: $12bfbb86ba5aff13$var$anumber,\n    bytes: $12bfbb86ba5aff13$var$abytes,\n    hash: $12bfbb86ba5aff13$var$ahash,\n    exists: $12bfbb86ba5aff13$var$aexists,\n    output: $12bfbb86ba5aff13$var$aoutput\n};\nmodule.exports.default = $12bfbb86ba5aff13$var$assert;\n\n});\n\nparcelRegister(\"9YMwy\", function(module, exports) {\n\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.Hash = module.exports.nextTick = module.exports.byteSwapIfBE = module.exports.byteSwap = module.exports.isLE = module.exports.rotl = module.exports.rotr = module.exports.createView = module.exports.u32 = module.exports.u8 = void 0;\nmodule.exports.isBytes = $743f5b81a9da9842$var$isBytes;\nmodule.exports.byteSwap32 = $743f5b81a9da9842$var$byteSwap32;\nmodule.exports.bytesToHex = $743f5b81a9da9842$var$bytesToHex;\nmodule.exports.hexToBytes = $743f5b81a9da9842$var$hexToBytes;\nmodule.exports.asyncLoop = $743f5b81a9da9842$var$asyncLoop;\nmodule.exports.utf8ToBytes = $743f5b81a9da9842$var$utf8ToBytes;\nmodule.exports.toBytes = $743f5b81a9da9842$var$toBytes;\nmodule.exports.concatBytes = $743f5b81a9da9842$var$concatBytes;\nmodule.exports.checkOpts = $743f5b81a9da9842$var$checkOpts;\nmodule.exports.wrapConstructor = $743f5b81a9da9842$var$wrapConstructor;\nmodule.exports.wrapConstructorWithOpts = $743f5b81a9da9842$var$wrapConstructorWithOpts;\nmodule.exports.wrapXOFConstructorWithOpts = $743f5b81a9da9842$var$wrapXOFConstructorWithOpts;\nmodule.exports.randomBytes = $743f5b81a9da9842$var$randomBytes;\n\nvar $g35Du = parcelRequire(\"g35Du\");\n\nvar $1BNC9 = parcelRequire(\"1BNC9\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction $743f5b81a9da9842$var$isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\n// Cast array to different type\nconst $743f5b81a9da9842$var$u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.u8 = $743f5b81a9da9842$var$u8;\nconst $743f5b81a9da9842$var$u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nmodule.exports.u32 = $743f5b81a9da9842$var$u32;\n// Cast array to view\nconst $743f5b81a9da9842$var$createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.createView = $743f5b81a9da9842$var$createView;\n// The rotate right (circular right shift) operation for uint32\nconst $743f5b81a9da9842$var$rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nmodule.exports.rotr = $743f5b81a9da9842$var$rotr;\n// The rotate left (circular left shift) operation for uint32\nconst $743f5b81a9da9842$var$rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nmodule.exports.rotl = $743f5b81a9da9842$var$rotl;\nmodule.exports.isLE = (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nconst $743f5b81a9da9842$var$byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\nmodule.exports.byteSwap = $743f5b81a9da9842$var$byteSwap;\n// Conditionally byte swap if on a big-endian platform\nmodule.exports.byteSwapIfBE = module.exports.isLE ? (n)=>n : (n)=>(0, module.exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction $743f5b81a9da9842$var$byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++)arr[i] = (0, module.exports.byteSwap)(arr[i]);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst $743f5b81a9da9842$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $743f5b81a9da9842$var$bytesToHex(bytes) {\n    (0, $1BNC9.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $743f5b81a9da9842$var$hexes[bytes[i]];\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst $743f5b81a9da9842$var$asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction $743f5b81a9da9842$var$asciiToBase16(ch) {\n    if (ch >= $743f5b81a9da9842$var$asciis._0 && ch <= $743f5b81a9da9842$var$asciis._9) return ch - $743f5b81a9da9842$var$asciis._0; // '2' => 50-48\n    if (ch >= $743f5b81a9da9842$var$asciis.A && ch <= $743f5b81a9da9842$var$asciis.F) return ch - ($743f5b81a9da9842$var$asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= $743f5b81a9da9842$var$asciis.a && ch <= $743f5b81a9da9842$var$asciis.f) return ch - ($743f5b81a9da9842$var$asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $743f5b81a9da9842$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = $743f5b81a9da9842$var$asciiToBase16(hex.charCodeAt(hi));\n        const n2 = $743f5b81a9da9842$var$asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst $743f5b81a9da9842$var$nextTick = async ()=>{};\nmodule.exports.nextTick = $743f5b81a9da9842$var$nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function $743f5b81a9da9842$var$asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, module.exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $743f5b81a9da9842$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function $743f5b81a9da9842$var$toBytes(data) {\n    if (typeof data === 'string') data = $743f5b81a9da9842$var$utf8ToBytes(data);\n    (0, $1BNC9.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function $743f5b81a9da9842$var$concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0, $1BNC9.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass $743f5b81a9da9842$var$Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nmodule.exports.Hash = $743f5b81a9da9842$var$Hash;\nfunction $743f5b81a9da9842$var$checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction $743f5b81a9da9842$var$wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update($743f5b81a9da9842$var$toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction $743f5b81a9da9842$var$wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($743f5b81a9da9842$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction $743f5b81a9da9842$var$wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($743f5b81a9da9842$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function $743f5b81a9da9842$var$randomBytes(bytesLength = 32) {\n    if ($g35Du.crypto && typeof $g35Du.crypto.getRandomValues === 'function') return $g35Du.crypto.getRandomValues(new Uint8Array(bytesLength));\n    // Legacy Node.js compatibility\n    if ($g35Du.crypto && typeof $g35Du.crypto.randomBytes === 'function') return $g35Du.crypto.randomBytes(bytesLength);\n    throw new Error('crypto.getRandomValues must be defined');\n}\n\n});\nparcelRegister(\"g35Du\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.crypto = void 0;\nmodule.exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n});\n\n\n\n\nparcelRegister(\"2kyNN\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.getHash = $1b2871fdba5348e8$var$getHash;\nmodule.exports.createCurve = $1b2871fdba5348e8$var$createCurve;\n\nvar $cLviI = parcelRequire(\"cLviI\");\n\nvar $9YMwy = parcelRequire(\"9YMwy\");\n\nvar $7lNi7 = parcelRequire(\"7lNi7\");\n// connects noble-curves to noble-hashes\nfunction $1b2871fdba5348e8$var$getHash(hash) {\n    return {\n        hash: hash,\n        hmac: (key, ...msgs)=>(0, $cLviI.hmac)(hash, key, (0, $9YMwy.concatBytes)(...msgs)),\n        randomBytes: $9YMwy.randomBytes\n    };\n}\nfunction $1b2871fdba5348e8$var$createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, $7lNi7.weierstrass)({\n            ...curveDef,\n            ...$1b2871fdba5348e8$var$getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create: create\n    });\n}\n\n});\nparcelRegister(\"cLviI\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.hmac = module.exports.HMAC = void 0;\n\nvar $1BNC9 = parcelRequire(\"1BNC9\");\n\nvar $9YMwy = parcelRequire(\"9YMwy\");\n// HMAC (RFC 2104)\nclass $94b2278aec7365b2$var$HMAC extends $9YMwy.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, $1BNC9.ahash)(hash);\n        const key = (0, $9YMwy.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, $1BNC9.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, $1BNC9.aexists)(this);\n        (0, $1BNC9.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash: oHash, iHash: iHash, finished: finished, destroyed: destroyed, blockLen: blockLen, outputLen: outputLen } = this;\n        to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nmodule.exports.HMAC = $94b2278aec7365b2$var$HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const $94b2278aec7365b2$var$hmac = (hash, key, message)=>new $94b2278aec7365b2$var$HMAC(hash, key).update(message).digest();\nmodule.exports.hmac = $94b2278aec7365b2$var$hmac;\nmodule.exports.hmac.create = (hash, key)=>new $94b2278aec7365b2$var$HMAC(hash, key);\n\n});\n\nparcelRegister(\"7lNi7\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.DER = void 0;\nmodule.exports.weierstrassPoints = $55a0bac5c8bffc9a$var$weierstrassPoints;\nmodule.exports.weierstrass = $55a0bac5c8bffc9a$var$weierstrass;\nmodule.exports.SWUFpSqrtRatio = $55a0bac5c8bffc9a$var$SWUFpSqrtRatio;\nmodule.exports.mapToCurveSimpleSWU = $55a0bac5c8bffc9a$var$mapToCurveSimpleSWU;\n\nvar $kswOL = parcelRequire(\"kswOL\");\n\nvar $i945l = parcelRequire(\"i945l\");\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\nfunction $55a0bac5c8bffc9a$var$validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0, $1GzxI.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined) (0, $1GzxI.abool)('prehash', opts.prehash);\n}\nfunction $55a0bac5c8bffc9a$var$validatePointOpts(curve) {\n    const opts = (0, $kswOL.validateBasic)(curve);\n    $1GzxI.validateObject(opts, {\n        a: 'field',\n        b: 'field'\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function'\n    });\n    const { endo: endo, Fp: Fp, a: a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nconst { bytesToNumberBE: $55a0bac5c8bffc9a$var$b2n, hexToBytes: $55a0bac5c8bffc9a$var$h2b } = $1GzxI;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ module.exports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = ''){\n            super(m);\n        }\n    },\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = module.exports.DER;\n            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n            if (data.length & 1) throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = $1GzxI.numberToHexUnpadded(dataLen);\n            if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? $1GzxI.numberToHexUnpadded(len.length / 2 | 128) : '';\n            const t = $1GzxI.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = module.exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E('tlv.decode: wrong value length');\n            return {\n                v: v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = module.exports.DER;\n            if (num < $55a0bac5c8bffc9a$var$_0n) throw new E('integer: negative integers are not allowed');\n            let hex = $1GzxI.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = '00' + hex;\n            if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = module.exports.DER;\n            if (data[0] & 128) throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');\n            return $55a0bac5c8bffc9a$var$b2n(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = module.exports.DER;\n        const data = typeof hex === 'string' ? $55a0bac5c8bffc9a$var$h2b(hex) : hex;\n        $1GzxI.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = module.exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst $55a0bac5c8bffc9a$var$_0n = BigInt(0), $55a0bac5c8bffc9a$var$_1n = BigInt(1), $55a0bac5c8bffc9a$var$_2n = BigInt(2), $55a0bac5c8bffc9a$var$_3n = BigInt(3), $55a0bac5c8bffc9a$var$_4n = BigInt(4);\nfunction $55a0bac5c8bffc9a$var$weierstrassPoints(opts) {\n    const CURVE = $55a0bac5c8bffc9a$var$validatePointOpts(opts);\n    const { Fp: Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = $i945l.Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return $1GzxI.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x: x,\n            y: y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a: a, b: b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return $1GzxI.inRange(num, $55a0bac5c8bffc9a$var$_1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength: nByteLength, wrapPrivateKey: wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if ($1GzxI.isBytes(key)) key = $1GzxI.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num = typeof key === 'bigint' ? key : $1GzxI.bytesToNumberBE((0, $1GzxI.ensureBytes)('private key', key, nByteLength));\n        } catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey) num = $i945l.mod(num, N); // disabled by default, enabled for BLS\n        $1GzxI.aInRange('private key', num, $55a0bac5c8bffc9a$var$_1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = (0, $1GzxI.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x: x,\n            y: y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, $1GzxI.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x: x, y: y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error('x required');\n            if (py == null || !Fp.isValid(py)) throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x: x, y: y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n            if (p instanceof Point) throw new Error('projective point not allowed');\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, $1GzxI.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, $kswOL.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y: y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a: a, b: b } = CURVE;\n            const b3 = Fp.mul(b, $55a0bac5c8bffc9a$var$_3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, $55a0bac5c8bffc9a$var$_3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo: endo, n: N } = CURVE;\n            $1GzxI.aInRange('scalar', sc, $55a0bac5c8bffc9a$var$_0n, N);\n            const I = Point.ZERO;\n            if (sc === $55a0bac5c8bffc9a$var$_0n) return I;\n            if (this.is0() || sc === $55a0bac5c8bffc9a$var$_1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > $55a0bac5c8bffc9a$var$_0n || k2 > $55a0bac5c8bffc9a$var$_0n){\n                if (k1 & $55a0bac5c8bffc9a$var$_1n) k1p = k1p.add(d);\n                if (k2 & $55a0bac5c8bffc9a$var$_1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= $55a0bac5c8bffc9a$var$_1n;\n                k2 >>= $55a0bac5c8bffc9a$var$_1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo: endo, n: N } = CURVE;\n            $1GzxI.aInRange('scalar', scalar, $55a0bac5c8bffc9a$var$_1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p: p, f: f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === $55a0bac5c8bffc9a$var$_0n || a === $55a0bac5c8bffc9a$var$_1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree: isTorsionFree } = CURVE;\n            if (cofactor === $55a0bac5c8bffc9a$var$_1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor: clearCofactor } = CURVE;\n            if (cofactor === $55a0bac5c8bffc9a$var$_1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, $1GzxI.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, $1GzxI.abool)('isCompressed', isCompressed);\n            return $1GzxI.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, $kswOL.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE: CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        weierstrassEquation: weierstrassEquation,\n        isWithinCurveOrder: isWithinCurveOrder\n    };\n}\nfunction $55a0bac5c8bffc9a$var$validateOpts(curve) {\n    const opts = (0, $kswOL.validateBasic)(curve);\n    $1GzxI.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function'\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean'\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function $55a0bac5c8bffc9a$var$weierstrass(curveDef) {\n    const CURVE = $55a0bac5c8bffc9a$var$validateOpts(curveDef);\n    const { Fp: Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return $i945l.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return $i945l.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar: normPrivateKeyToScalar, weierstrassEquation: weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder } = $55a0bac5c8bffc9a$var$weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = $1GzxI.concatBytes;\n            (0, $1GzxI.abool)('isCompressed', isCompressed);\n            if (isCompressed) return cat(Uint8Array.from([\n                point.hasEvenY() ? 0x02 : 0x03\n            ]), x);\n            else return cat(Uint8Array.from([\n                0x04\n            ]), x, Fp.toBytes(a.y));\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = $1GzxI.bytesToNumberBE(tail);\n                if (!$1GzxI.inRange(x, $55a0bac5c8bffc9a$var$_1n, Fp.ORDER)) throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & $55a0bac5c8bffc9a$var$_1n) === $55a0bac5c8bffc9a$var$_1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x: x,\n                    y: y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x: x,\n                    y: y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>$1GzxI.bytesToHex($1GzxI.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> $55a0bac5c8bffc9a$var$_1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>$1GzxI.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, $1GzxI.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r: r, s: s } = module.exports.DER.toSig((0, $1GzxI.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            $1GzxI.aInRange('r', this.r, $55a0bac5c8bffc9a$var$_1n, CURVE_ORDER); // r in [1..N]\n            $1GzxI.aInRange('s', this.s, $55a0bac5c8bffc9a$var$_1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r: r, s: s, recovery: rec } = this;\n            const h = bits2int_modN((0, $1GzxI.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return $1GzxI.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return module.exports.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return $1GzxI.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = $i945l.getMinHashLength(CURVE.n);\n            return $i945l.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = $1GzxI.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error('first arg must be private key');\n        if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\"\n        if (bytes.length > 8192) throw new Error('input is too large');\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = $1GzxI.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = $1GzxI.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        $1GzxI.aInRange('num < 2^' + CURVE.nBitLength, num, $55a0bac5c8bffc9a$var$_0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return $1GzxI.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            'recovered',\n            'canonical'\n        ].some((k)=>k in opts)) throw new Error('sign() legacy options not supported');\n        const { hash: hash, randomBytes: randomBytes } = CURVE;\n        let { lowS: lowS, prehash: prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, $1GzxI.ensureBytes)('msgHash', msgHash);\n        $55a0bac5c8bffc9a$var$validateSigVerOpts(opts);\n        if (prehash) msgHash = (0, $1GzxI.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, $1GzxI.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = $1GzxI.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === $55a0bac5c8bffc9a$var$_0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === $55a0bac5c8bffc9a$var$_0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & $55a0bac5c8bffc9a$var$_1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed: seed,\n            k2sig: k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed: seed, k2sig: k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = $1GzxI.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, $1GzxI.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, $1GzxI.ensureBytes)('publicKey', publicKey);\n        const { lowS: lowS, prehash: prehash, format: format } = opts;\n        // Verify opts, deduce signature format\n        $55a0bac5c8bffc9a$var$validateSigVerOpts(opts);\n        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der') throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || $1GzxI.isBytes(sg);\n        const isObj = !isHex && !format && typeof sg === 'object' && sg !== null && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';\n        if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact') _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof module.exports.DER.Err)) throw derError;\n                }\n                if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r: r, s: s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE: CURVE,\n        getPublicKey: getPublicKey,\n        getSharedSecret: getSharedSecret,\n        sign: sign,\n        verify: verify,\n        ProjectivePoint: Point,\n        Signature: Signature,\n        utils: utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function $55a0bac5c8bffc9a$var$SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = $55a0bac5c8bffc9a$var$_0n;\n    for(let o = q - $55a0bac5c8bffc9a$var$_1n; o % $55a0bac5c8bffc9a$var$_2n === $55a0bac5c8bffc9a$var$_0n; o /= $55a0bac5c8bffc9a$var$_2n)l += $55a0bac5c8bffc9a$var$_1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = $55a0bac5c8bffc9a$var$_2n << c1 - $55a0bac5c8bffc9a$var$_1n - $55a0bac5c8bffc9a$var$_1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * $55a0bac5c8bffc9a$var$_2n;\n    const c2 = (q - $55a0bac5c8bffc9a$var$_1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - $55a0bac5c8bffc9a$var$_1n) / $55a0bac5c8bffc9a$var$_2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - $55a0bac5c8bffc9a$var$_1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + $55a0bac5c8bffc9a$var$_1n) / $55a0bac5c8bffc9a$var$_2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > $55a0bac5c8bffc9a$var$_1n; i--){\n            let tv5 = i - $55a0bac5c8bffc9a$var$_2n; // 18.    tv5 = i - 2\n            tv5 = $55a0bac5c8bffc9a$var$_2n << tv5 - $55a0bac5c8bffc9a$var$_1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % $55a0bac5c8bffc9a$var$_4n === $55a0bac5c8bffc9a$var$_3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - $55a0bac5c8bffc9a$var$_3n) / $55a0bac5c8bffc9a$var$_4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function $55a0bac5c8bffc9a$var$mapToCurveSimpleSWU(Fp, opts) {\n    $i945l.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = $55a0bac5c8bffc9a$var$SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid: isValid, value: value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\n\n});\nparcelRegister(\"kswOL\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n\nvar $i945l = parcelRequire(\"i945l\");\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n        windows: windows,\n        windowSize: windowSize\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error('array expected');\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate: constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n, p = c.ZERO) {\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) // The most important part for const-time getPublicKey\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                else p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p: p,\n                f: f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                if (n === _0n) break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0) continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0) curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length) throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = (0, $1GzxI.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < scalars.length; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, $i945l.validateField)(curve.Fp);\n    (0, $1GzxI.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field'\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger'\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, $i945l.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        p: curve.Fp.ORDER\n    });\n}\n\n});\nparcelRegister(\"i945l\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.isNegativeLE = void 0;\nmodule.exports.mod = $d35c3c82524fc7f9$var$mod;\nmodule.exports.pow = $d35c3c82524fc7f9$var$pow;\nmodule.exports.pow2 = $d35c3c82524fc7f9$var$pow2;\nmodule.exports.invert = $d35c3c82524fc7f9$var$invert;\nmodule.exports.tonelliShanks = $d35c3c82524fc7f9$var$tonelliShanks;\nmodule.exports.FpSqrt = $d35c3c82524fc7f9$var$FpSqrt;\nmodule.exports.validateField = $d35c3c82524fc7f9$var$validateField;\nmodule.exports.FpPow = $d35c3c82524fc7f9$var$FpPow;\nmodule.exports.FpInvertBatch = $d35c3c82524fc7f9$var$FpInvertBatch;\nmodule.exports.FpDiv = $d35c3c82524fc7f9$var$FpDiv;\nmodule.exports.FpLegendre = $d35c3c82524fc7f9$var$FpLegendre;\nmodule.exports.FpIsSquare = $d35c3c82524fc7f9$var$FpIsSquare;\nmodule.exports.nLength = $d35c3c82524fc7f9$var$nLength;\nmodule.exports.Field = $d35c3c82524fc7f9$var$Field;\nmodule.exports.FpSqrtOdd = $d35c3c82524fc7f9$var$FpSqrtOdd;\nmodule.exports.FpSqrtEven = $d35c3c82524fc7f9$var$FpSqrtEven;\nmodule.exports.hashToPrivateScalar = $d35c3c82524fc7f9$var$hashToPrivateScalar;\nmodule.exports.getFieldBytesLength = $d35c3c82524fc7f9$var$getFieldBytesLength;\nmodule.exports.getMinHashLength = $d35c3c82524fc7f9$var$getMinHashLength;\nmodule.exports.mapHashToField = $d35c3c82524fc7f9$var$mapHashToField;\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\n// prettier-ignore\nconst $d35c3c82524fc7f9$var$_0n = BigInt(0), $d35c3c82524fc7f9$var$_1n = BigInt(1), $d35c3c82524fc7f9$var$_2n = /* @__PURE__ */ BigInt(2), $d35c3c82524fc7f9$var$_3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst $d35c3c82524fc7f9$var$_4n = /* @__PURE__ */ BigInt(4), $d35c3c82524fc7f9$var$_5n = /* @__PURE__ */ BigInt(5), $d35c3c82524fc7f9$var$_8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst $d35c3c82524fc7f9$var$_9n = /* @__PURE__ */ BigInt(9), $d35c3c82524fc7f9$var$_16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction $d35c3c82524fc7f9$var$mod(a, b) {\n    const result = a % b;\n    return result >= $d35c3c82524fc7f9$var$_0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction $d35c3c82524fc7f9$var$pow(num, power, modulo) {\n    if (power < $d35c3c82524fc7f9$var$_0n) throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= $d35c3c82524fc7f9$var$_0n) throw new Error('invalid modulus');\n    if (modulo === $d35c3c82524fc7f9$var$_1n) return $d35c3c82524fc7f9$var$_0n;\n    let res = $d35c3c82524fc7f9$var$_1n;\n    while(power > $d35c3c82524fc7f9$var$_0n){\n        if (power & $d35c3c82524fc7f9$var$_1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= $d35c3c82524fc7f9$var$_1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction $d35c3c82524fc7f9$var$pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > $d35c3c82524fc7f9$var$_0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction $d35c3c82524fc7f9$var$invert(number, modulo) {\n    if (number === $d35c3c82524fc7f9$var$_0n) throw new Error('invert: expected non-zero number');\n    if (modulo <= $d35c3c82524fc7f9$var$_0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = $d35c3c82524fc7f9$var$mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = $d35c3c82524fc7f9$var$_0n, y = $d35c3c82524fc7f9$var$_1n, u = $d35c3c82524fc7f9$var$_1n, v = $d35c3c82524fc7f9$var$_0n;\n    while(a !== $d35c3c82524fc7f9$var$_0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== $d35c3c82524fc7f9$var$_1n) throw new Error('invert: does not exist');\n    return $d35c3c82524fc7f9$var$mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function $d35c3c82524fc7f9$var$tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - $d35c3c82524fc7f9$var$_1n) / $d35c3c82524fc7f9$var$_2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - $d35c3c82524fc7f9$var$_1n, S = 0; Q % $d35c3c82524fc7f9$var$_2n === $d35c3c82524fc7f9$var$_0n; Q /= $d35c3c82524fc7f9$var$_2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = $d35c3c82524fc7f9$var$_2n; Z < P && $d35c3c82524fc7f9$var$pow(Z, legendreC, P) !== P - $d35c3c82524fc7f9$var$_1n; Z++){\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + $d35c3c82524fc7f9$var$_1n) / $d35c3c82524fc7f9$var$_4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + $d35c3c82524fc7f9$var$_1n) / $d35c3c82524fc7f9$var$_2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, $d35c3c82524fc7f9$var$_1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction $d35c3c82524fc7f9$var$FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % $d35c3c82524fc7f9$var$_4n === $d35c3c82524fc7f9$var$_3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + $d35c3c82524fc7f9$var$_1n) / $d35c3c82524fc7f9$var$_4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % $d35c3c82524fc7f9$var$_8n === $d35c3c82524fc7f9$var$_5n) {\n        const c1 = (P - $d35c3c82524fc7f9$var$_5n) / $d35c3c82524fc7f9$var$_8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, $d35c3c82524fc7f9$var$_2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, $d35c3c82524fc7f9$var$_2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    $d35c3c82524fc7f9$var$_9n;\n    // Other cases: Tonelli-Shanks algorithm\n    return $d35c3c82524fc7f9$var$tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst $d35c3c82524fc7f9$var$isNegativeLE = (num, modulo)=>($d35c3c82524fc7f9$var$mod(num, modulo) & $d35c3c82524fc7f9$var$_1n) === $d35c3c82524fc7f9$var$_1n;\nmodule.exports.isNegativeLE = $d35c3c82524fc7f9$var$isNegativeLE;\n// prettier-ignore\nconst $d35c3c82524fc7f9$var$FIELD_FIELDS = [\n    'create',\n    'isValid',\n    'is0',\n    'neg',\n    'inv',\n    'sqrt',\n    'sqr',\n    'eql',\n    'add',\n    'sub',\n    'mul',\n    'pow',\n    'div',\n    'addN',\n    'subN',\n    'mulN',\n    'sqrN'\n];\nfunction $d35c3c82524fc7f9$var$validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger'\n    };\n    const opts = $d35c3c82524fc7f9$var$FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, $1GzxI.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function $d35c3c82524fc7f9$var$FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < $d35c3c82524fc7f9$var$_0n) throw new Error('invalid exponent, negatives unsupported');\n    if (power === $d35c3c82524fc7f9$var$_0n) return f.ONE;\n    if (power === $d35c3c82524fc7f9$var$_1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > $d35c3c82524fc7f9$var$_0n){\n        if (power & $d35c3c82524fc7f9$var$_1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= $d35c3c82524fc7f9$var$_1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function $d35c3c82524fc7f9$var$FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction $d35c3c82524fc7f9$var$FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? $d35c3c82524fc7f9$var$invert(rhs, f.ORDER) : f.inv(rhs));\n}\nfunction $d35c3c82524fc7f9$var$FpLegendre(order) {\n    // (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n    // (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreConst = (order - $d35c3c82524fc7f9$var$_1n) / $d35c3c82524fc7f9$var$_2n; // Integer arithmetic\n    return (f, x)=>f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction $d35c3c82524fc7f9$var$FpIsSquare(f) {\n    const legendre = $d35c3c82524fc7f9$var$FpLegendre(f.ORDER);\n    return (x)=>{\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction $d35c3c82524fc7f9$var$nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength: nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function $d35c3c82524fc7f9$var$Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= $d35c3c82524fc7f9$var$_0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = $d35c3c82524fc7f9$var$nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER: ORDER,\n        BITS: BITS,\n        BYTES: BYTES,\n        MASK: (0, $1GzxI.bitMask)(BITS),\n        ZERO: $d35c3c82524fc7f9$var$_0n,\n        ONE: $d35c3c82524fc7f9$var$_1n,\n        create: (num)=>$d35c3c82524fc7f9$var$mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return $d35c3c82524fc7f9$var$_0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === $d35c3c82524fc7f9$var$_0n,\n        isOdd: (num)=>(num & $d35c3c82524fc7f9$var$_1n) === $d35c3c82524fc7f9$var$_1n,\n        neg: (num)=>$d35c3c82524fc7f9$var$mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>$d35c3c82524fc7f9$var$mod(num * num, ORDER),\n        add: (lhs, rhs)=>$d35c3c82524fc7f9$var$mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>$d35c3c82524fc7f9$var$mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>$d35c3c82524fc7f9$var$mod(lhs * rhs, ORDER),\n        pow: (num, power)=>$d35c3c82524fc7f9$var$FpPow(f, num, power),\n        div: (lhs, rhs)=>$d35c3c82524fc7f9$var$mod(lhs * $d35c3c82524fc7f9$var$invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>$d35c3c82524fc7f9$var$invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = $d35c3c82524fc7f9$var$FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        invertBatch: (lst)=>$d35c3c82524fc7f9$var$FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0, $1GzxI.numberToBytesLE)(num, BYTES) : (0, $1GzxI.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0, $1GzxI.bytesToNumberLE)(bytes) : (0, $1GzxI.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nfunction $d35c3c82524fc7f9$var$FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction $d35c3c82524fc7f9$var$FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function $d35c3c82524fc7f9$var$hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, $1GzxI.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = $d35c3c82524fc7f9$var$nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, $1GzxI.bytesToNumberLE)(hash) : (0, $1GzxI.bytesToNumberBE)(hash);\n    return $d35c3c82524fc7f9$var$mod(num, groupOrder - $d35c3c82524fc7f9$var$_1n) + $d35c3c82524fc7f9$var$_1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function $d35c3c82524fc7f9$var$getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function $d35c3c82524fc7f9$var$getMinHashLength(fieldOrder) {\n    const length = $d35c3c82524fc7f9$var$getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function $d35c3c82524fc7f9$var$mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = $d35c3c82524fc7f9$var$getFieldBytesLength(fieldOrder);\n    const minLen = $d35c3c82524fc7f9$var$getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, $1GzxI.bytesToNumberBE)(key) : (0, $1GzxI.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = $d35c3c82524fc7f9$var$mod(num, fieldOrder - $d35c3c82524fc7f9$var$_1n) + $d35c3c82524fc7f9$var$_1n;\n    return isLE ? (0, $1GzxI.numberToBytesLE)(reduced, fieldLen) : (0, $1GzxI.numberToBytesBE)(reduced, fieldLen);\n}\n\n});\nparcelRegister(\"1GzxI\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.notImplemented = module.exports.bitMask = void 0;\nmodule.exports.isBytes = $13a548bfcdef076f$var$isBytes;\nmodule.exports.abytes = $13a548bfcdef076f$var$abytes;\nmodule.exports.abool = $13a548bfcdef076f$var$abool;\nmodule.exports.bytesToHex = $13a548bfcdef076f$var$bytesToHex;\nmodule.exports.numberToHexUnpadded = $13a548bfcdef076f$var$numberToHexUnpadded;\nmodule.exports.hexToNumber = $13a548bfcdef076f$var$hexToNumber;\nmodule.exports.hexToBytes = $13a548bfcdef076f$var$hexToBytes;\nmodule.exports.bytesToNumberBE = $13a548bfcdef076f$var$bytesToNumberBE;\nmodule.exports.bytesToNumberLE = $13a548bfcdef076f$var$bytesToNumberLE;\nmodule.exports.numberToBytesBE = $13a548bfcdef076f$var$numberToBytesBE;\nmodule.exports.numberToBytesLE = $13a548bfcdef076f$var$numberToBytesLE;\nmodule.exports.numberToVarBytesBE = $13a548bfcdef076f$var$numberToVarBytesBE;\nmodule.exports.ensureBytes = $13a548bfcdef076f$var$ensureBytes;\nmodule.exports.concatBytes = $13a548bfcdef076f$var$concatBytes;\nmodule.exports.equalBytes = $13a548bfcdef076f$var$equalBytes;\nmodule.exports.utf8ToBytes = $13a548bfcdef076f$var$utf8ToBytes;\nmodule.exports.inRange = $13a548bfcdef076f$var$inRange;\nmodule.exports.aInRange = $13a548bfcdef076f$var$aInRange;\nmodule.exports.bitLen = $13a548bfcdef076f$var$bitLen;\nmodule.exports.bitGet = $13a548bfcdef076f$var$bitGet;\nmodule.exports.bitSet = $13a548bfcdef076f$var$bitSet;\nmodule.exports.createHmacDrbg = $13a548bfcdef076f$var$createHmacDrbg;\nmodule.exports.validateObject = $13a548bfcdef076f$var$validateObject;\nmodule.exports.memoized = $13a548bfcdef076f$var$memoized;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst $13a548bfcdef076f$var$_0n = /* @__PURE__ */ BigInt(0);\nconst $13a548bfcdef076f$var$_1n = /* @__PURE__ */ BigInt(1);\nconst $13a548bfcdef076f$var$_2n = /* @__PURE__ */ BigInt(2);\nfunction $13a548bfcdef076f$var$isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\nfunction $13a548bfcdef076f$var$abytes(item) {\n    if (!$13a548bfcdef076f$var$isBytes(item)) throw new Error('Uint8Array expected');\n}\nfunction $13a548bfcdef076f$var$abool(title, value) {\n    if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst $13a548bfcdef076f$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $13a548bfcdef076f$var$bytesToHex(bytes) {\n    $13a548bfcdef076f$var$abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $13a548bfcdef076f$var$hexes[bytes[i]];\n    return hex;\n}\nfunction $13a548bfcdef076f$var$numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction $13a548bfcdef076f$var$hexToNumber(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? $13a548bfcdef076f$var$_0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst $13a548bfcdef076f$var$asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction $13a548bfcdef076f$var$asciiToBase16(ch) {\n    if (ch >= $13a548bfcdef076f$var$asciis._0 && ch <= $13a548bfcdef076f$var$asciis._9) return ch - $13a548bfcdef076f$var$asciis._0; // '2' => 50-48\n    if (ch >= $13a548bfcdef076f$var$asciis.A && ch <= $13a548bfcdef076f$var$asciis.F) return ch - ($13a548bfcdef076f$var$asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= $13a548bfcdef076f$var$asciis.a && ch <= $13a548bfcdef076f$var$asciis.f) return ch - ($13a548bfcdef076f$var$asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $13a548bfcdef076f$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = $13a548bfcdef076f$var$asciiToBase16(hex.charCodeAt(hi));\n        const n2 = $13a548bfcdef076f$var$asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction $13a548bfcdef076f$var$bytesToNumberBE(bytes) {\n    return $13a548bfcdef076f$var$hexToNumber($13a548bfcdef076f$var$bytesToHex(bytes));\n}\nfunction $13a548bfcdef076f$var$bytesToNumberLE(bytes) {\n    $13a548bfcdef076f$var$abytes(bytes);\n    return $13a548bfcdef076f$var$hexToNumber($13a548bfcdef076f$var$bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction $13a548bfcdef076f$var$numberToBytesBE(n, len) {\n    return $13a548bfcdef076f$var$hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction $13a548bfcdef076f$var$numberToBytesLE(n, len) {\n    return $13a548bfcdef076f$var$numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction $13a548bfcdef076f$var$numberToVarBytesBE(n) {\n    return $13a548bfcdef076f$var$hexToBytes($13a548bfcdef076f$var$numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function $13a548bfcdef076f$var$ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') try {\n        res = $13a548bfcdef076f$var$hexToBytes(hex);\n    } catch (e) {\n        throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n    else if ($13a548bfcdef076f$var$isBytes(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n    else throw new Error(title + ' must be hex string or Uint8Array');\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function $13a548bfcdef076f$var$concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        $13a548bfcdef076f$var$abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction $13a548bfcdef076f$var$equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $13a548bfcdef076f$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst $13a548bfcdef076f$var$isPosBig = (n)=>typeof n === 'bigint' && $13a548bfcdef076f$var$_0n <= n;\nfunction $13a548bfcdef076f$var$inRange(n, min, max) {\n    return $13a548bfcdef076f$var$isPosBig(n) && $13a548bfcdef076f$var$isPosBig(min) && $13a548bfcdef076f$var$isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function $13a548bfcdef076f$var$aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!$13a548bfcdef076f$var$inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function $13a548bfcdef076f$var$bitLen(n) {\n    let len;\n    for(len = 0; n > $13a548bfcdef076f$var$_0n; n >>= $13a548bfcdef076f$var$_1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function $13a548bfcdef076f$var$bitGet(n, pos) {\n    return n >> BigInt(pos) & $13a548bfcdef076f$var$_1n;\n}\n/**\n * Sets single bit at position.\n */ function $13a548bfcdef076f$var$bitSet(n, pos, value) {\n    return n | (value ? $13a548bfcdef076f$var$_1n : $13a548bfcdef076f$var$_0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const $13a548bfcdef076f$var$bitMask = (n)=>($13a548bfcdef076f$var$_2n << BigInt(n - 1)) - $13a548bfcdef076f$var$_1n;\nmodule.exports.bitMask = $13a548bfcdef076f$var$bitMask;\n// DRBG\nconst $13a548bfcdef076f$var$u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst $13a548bfcdef076f$var$u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function $13a548bfcdef076f$var$createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = $13a548bfcdef076f$var$u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = $13a548bfcdef076f$var$u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = $13a548bfcdef076f$var$u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h($13a548bfcdef076f$var$u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h($13a548bfcdef076f$var$u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return $13a548bfcdef076f$var$concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst $13a548bfcdef076f$var$validatorFns = {\n    bigint: (val)=>typeof val === 'bigint',\n    function: (val)=>typeof val === 'function',\n    boolean: (val)=>typeof val === 'boolean',\n    string: (val)=>typeof val === 'string',\n    stringOrUint8Array: (val)=>typeof val === 'string' || $13a548bfcdef076f$var$isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction $13a548bfcdef076f$var$validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = $13a548bfcdef076f$var$validatorFns[type];\n        if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */ const $13a548bfcdef076f$var$notImplemented = ()=>{\n    throw new Error('not implemented');\n};\nmodule.exports.notImplemented = $13a548bfcdef076f$var$notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function $13a548bfcdef076f$var$memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n\n});\n\n\n\n\n\nparcelRegister(\"57dpp\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.expand_message_xmd = $3b9801ed630d510a$var$expand_message_xmd;\nmodule.exports.expand_message_xof = $3b9801ed630d510a$var$expand_message_xof;\nmodule.exports.hash_to_field = $3b9801ed630d510a$var$hash_to_field;\nmodule.exports.isogenyMap = $3b9801ed630d510a$var$isogenyMap;\nmodule.exports.createHasher = $3b9801ed630d510a$var$createHasher;\n\nvar $i945l = parcelRequire(\"i945l\");\n\nvar $1GzxI = parcelRequire(\"1GzxI\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst $3b9801ed630d510a$var$os2ip = $1GzxI.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction $3b9801ed630d510a$var$i2osp(value, length) {\n    $3b9801ed630d510a$var$anum(value);\n    $3b9801ed630d510a$var$anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({\n        length: length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction $3b9801ed630d510a$var$strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];\n    return arr;\n}\nfunction $3b9801ed630d510a$var$anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction $3b9801ed630d510a$var$expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, $1GzxI.abytes)(msg);\n    (0, $1GzxI.abytes)(DST);\n    $3b9801ed630d510a$var$anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0, $1GzxI.concatBytes)((0, $1GzxI.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, $1GzxI.concatBytes)(DST, $3b9801ed630d510a$var$i2osp(DST.length, 1));\n    const Z_pad = $3b9801ed630d510a$var$i2osp(0, r_in_bytes);\n    const l_i_b_str = $3b9801ed630d510a$var$i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, $1GzxI.concatBytes)(Z_pad, msg, l_i_b_str, $3b9801ed630d510a$var$i2osp(0, 1), DST_prime));\n    b[0] = H((0, $1GzxI.concatBytes)(b_0, $3b9801ed630d510a$var$i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            $3b9801ed630d510a$var$strxor(b_0, b[i - 1]),\n            $3b9801ed630d510a$var$i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, $1GzxI.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, $1GzxI.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction $3b9801ed630d510a$var$expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, $1GzxI.abytes)(msg);\n    (0, $1GzxI.abytes)(DST);\n    $3b9801ed630d510a$var$anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen: dkLen\n        }).update((0, $1GzxI.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update($3b9801ed630d510a$var$i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update($3b9801ed630d510a$var$i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function $3b9801ed630d510a$var$hash_to_field(msg, count, options) {\n    (0, $1GzxI.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash'\n    });\n    const { p: p, k: k, m: m, hash: hash, expand: expand, DST: _DST } = options;\n    (0, $1GzxI.abytes)(msg);\n    $3b9801ed630d510a$var$anum(count);\n    const DST = typeof _DST === 'string' ? (0, $1GzxI.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') prb = $3b9801ed630d510a$var$expand_message_xmd(msg, DST, len_in_bytes, hash);\n    else if (expand === 'xof') prb = $3b9801ed630d510a$var$expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    else if (expand === '_internal_pass') // for internal tests only\n    prb = msg;\n    else throw new Error('expand must be \"xmd\" or \"xof\"');\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, $i945l.mod)($3b9801ed630d510a$var$os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction $3b9801ed630d510a$var$isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\nfunction $3b9801ed630d510a$var$createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = $3b9801ed630d510a$var$hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = $3b9801ed630d510a$var$hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)if (typeof i !== 'bigint') throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n}\n\n});\n\n\nparcelRegister(\"eLZBv\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $ac153db803e0260e$export$2e2bcd8739ae039; });\n\nvar $lnAYI = parcelRequire(\"lnAYI\");\n\nvar $ZfjYC = parcelRequire(\"ZfjYC\");\n\nvar $dZ1ej = parcelRequire(\"dZ1ej\");\n\nvar $cQlYm = parcelRequire(\"cQlYm\");\nconst $ac153db803e0260e$var$poolSize = 20;\nconst $ac153db803e0260e$var$announceIntervalMs = 5333;\nconst $ac153db803e0260e$var$offerTtl = 57333;\nvar $ac153db803e0260e$export$2e2bcd8739ae039 = ({ init: init, subscribe: subscribe, announce: announce })=>{\n    const occupiedRooms = {};\n    let didInit = false;\n    let initPromises;\n    let offerPool;\n    let offerCleanupTimer;\n    return (config, roomId, onJoinError)=>{\n        const { appId: appId } = config;\n        if (occupiedRooms[appId]?.[roomId]) return occupiedRooms[appId][roomId];\n        const pendingOffers = {};\n        const connectedPeers = {};\n        const rootTopicPlaintext = (0, $cQlYm.topicPath)((0, $cQlYm.libName), appId, roomId);\n        const rootTopicP = (0, $lnAYI.sha1)(rootTopicPlaintext);\n        const selfTopicP = (0, $lnAYI.sha1)((0, $cQlYm.topicPath)(rootTopicPlaintext, (0, $cQlYm.selfId)));\n        const key = (0, $lnAYI.genKey)(config.password || '', appId, roomId);\n        const withKey = (f)=>async (signal)=>({\n                    type: signal.type,\n                    sdp: await f(key, signal.sdp)\n                });\n        const toPlain = withKey((0, $lnAYI.decrypt));\n        const toCipher = withKey((0, $lnAYI.encrypt));\n        const makeOffer = ()=>(0, $ZfjYC.default)(true, config.rtcConfig);\n        const connectPeer = (peer, peerId, clientId)=>{\n            if (connectedPeers[peerId]) {\n                if (connectedPeers[peerId] !== peer) peer.destroy();\n                return;\n            }\n            connectedPeers[peerId] = peer;\n            onPeerConnect(peer, peerId);\n            pendingOffers[peerId]?.forEach((peer, i)=>{\n                if (i !== clientId) peer.destroy();\n            });\n            delete pendingOffers[peerId];\n        };\n        const disconnectPeer = (peer, peerId)=>{\n            if (connectedPeers[peerId] === peer) delete connectedPeers[peerId];\n        };\n        const prunePendingOffer = (peerId, clientId)=>{\n            if (connectedPeers[peerId]) return;\n            const offer = pendingOffers[peerId]?.[clientId];\n            if (offer) {\n                delete pendingOffers[peerId][clientId];\n                offer.destroy();\n            }\n        };\n        const getOffers = (n)=>{\n            offerPool.push(...(0, $cQlYm.alloc)(n, makeOffer));\n            return (0, $cQlYm.all)(offerPool.splice(0, n).map((peer)=>peer.offerPromise.then(toCipher).then((offer)=>({\n                        peer: peer,\n                        offer: offer\n                    }))));\n        };\n        const handleJoinError = (peerId, sdpType)=>onJoinError?.({\n                error: `incorrect password (${config.password}) when decrypting ${sdpType}`,\n                appId: appId,\n                peerId: peerId,\n                roomId: roomId\n            });\n        const handleMessage = (clientId)=>async (topic, msg, signalPeer)=>{\n                const [rootTopic, selfTopic] = await (0, $cQlYm.all)([\n                    rootTopicP,\n                    selfTopicP\n                ]);\n                if (topic !== rootTopic && topic !== selfTopic) return;\n                const { peerId: peerId, offer: offer, answer: answer, peer: peer } = typeof msg === 'string' ? (0, $cQlYm.fromJson)(msg) : msg;\n                if (peerId === (0, $cQlYm.selfId) || connectedPeers[peerId]) return;\n                if (peerId && !offer && !answer) {\n                    if (pendingOffers[peerId]?.[clientId]) return;\n                    const [[{ peer: peer, offer: offer }], topic] = await (0, $cQlYm.all)([\n                        getOffers(1),\n                        (0, $lnAYI.sha1)((0, $cQlYm.topicPath)(rootTopicPlaintext, peerId))\n                    ]);\n                    pendingOffers[peerId] ||= [];\n                    pendingOffers[peerId][clientId] = peer;\n                    setTimeout(()=>prunePendingOffer(peerId, clientId), announceIntervals[clientId] * 0.9);\n                    peer.setHandlers({\n                        connect: ()=>connectPeer(peer, peerId, clientId),\n                        close: ()=>disconnectPeer(peer, peerId)\n                    });\n                    signalPeer(topic, (0, $cQlYm.toJson)({\n                        peerId: (0, $cQlYm.selfId),\n                        offer: offer\n                    }));\n                } else if (offer) {\n                    const myOffer = pendingOffers[peerId]?.[clientId];\n                    if (myOffer && (0, $cQlYm.selfId) > peerId) return;\n                    const peer = (0, $ZfjYC.default)(false, config.rtcConfig);\n                    peer.setHandlers({\n                        connect: ()=>connectPeer(peer, peerId, clientId),\n                        close: ()=>disconnectPeer(peer, peerId)\n                    });\n                    let plainOffer;\n                    try {\n                        plainOffer = await toPlain(offer);\n                    } catch (_) {\n                        handleJoinError(peerId, 'offer');\n                        return;\n                    }\n                    if (peer.isDead) return;\n                    const [topic, answer] = await (0, $cQlYm.all)([\n                        (0, $lnAYI.sha1)((0, $cQlYm.topicPath)(rootTopicPlaintext, peerId)),\n                        peer.signal(plainOffer)\n                    ]);\n                    signalPeer(topic, (0, $cQlYm.toJson)({\n                        peerId: (0, $cQlYm.selfId),\n                        answer: await toCipher(answer)\n                    }));\n                } else if (answer) {\n                    let plainAnswer;\n                    try {\n                        plainAnswer = await toPlain(answer);\n                    } catch (e) {\n                        handleJoinError(peerId, 'answer');\n                        return;\n                    }\n                    if (peer) {\n                        peer.setHandlers({\n                            connect: ()=>connectPeer(peer, peerId, clientId),\n                            close: ()=>disconnectPeer(peer, peerId)\n                        });\n                        peer.signal(plainAnswer);\n                    } else {\n                        const peer = pendingOffers[peerId]?.[clientId];\n                        if (peer && !peer.isDead) peer.signal(plainAnswer);\n                    }\n                }\n            };\n        if (!config) throw (0, $cQlYm.mkErr)('requires a config map as the first argument');\n        if (!appId && !config.firebaseApp) throw (0, $cQlYm.mkErr)('config map is missing appId field');\n        if (!roomId) throw (0, $cQlYm.mkErr)('roomId argument required');\n        if (!didInit) {\n            const initRes = init(config);\n            offerPool = (0, $cQlYm.alloc)($ac153db803e0260e$var$poolSize, makeOffer);\n            initPromises = Array.isArray(initRes) ? initRes : [\n                initRes\n            ];\n            didInit = true;\n            offerCleanupTimer = setInterval(()=>offerPool = offerPool.filter((peer)=>{\n                    const shouldLive = Date.now() - peer.created < $ac153db803e0260e$var$offerTtl;\n                    if (!shouldLive) peer.destroy();\n                    return shouldLive;\n                }), $ac153db803e0260e$var$offerTtl * 1.03);\n        }\n        const announceIntervals = initPromises.map(()=>$ac153db803e0260e$var$announceIntervalMs);\n        const announceTimeouts = [];\n        const unsubFns = initPromises.map(async (clientP, i)=>subscribe(await clientP, await rootTopicP, await selfTopicP, handleMessage(i), getOffers));\n        (0, $cQlYm.all)([\n            rootTopicP,\n            selfTopicP\n        ]).then(([rootTopic, selfTopic])=>{\n            const queueAnnounce = async (client, i)=>{\n                const ms = await announce(client, rootTopic, selfTopic);\n                if (typeof ms === 'number') announceIntervals[i] = ms;\n                announceTimeouts[i] = setTimeout(()=>queueAnnounce(client, i), announceIntervals[i]);\n            };\n            unsubFns.forEach(async (didSub, i)=>{\n                await didSub;\n                queueAnnounce(await initPromises[i], i);\n            });\n        });\n        let onPeerConnect = (0, $cQlYm.noOp);\n        occupiedRooms[appId] ||= {};\n        return occupiedRooms[appId][roomId] = (0, $dZ1ej.default)((f)=>onPeerConnect = f, (id)=>delete connectedPeers[id], ()=>{\n            delete occupiedRooms[appId][roomId];\n            announceTimeouts.forEach(clearTimeout);\n            unsubFns.forEach(async (f)=>(await f)());\n            clearInterval(offerCleanupTimer);\n        });\n    };\n};\n\n});\nparcelRegister(\"lnAYI\", function(module, exports) {\n\n$parcel$export(module.exports, \"sha1\", function () { return $f9086e0cc03499bb$export$5091bdda49ba90f5; });\n$parcel$export(module.exports, \"genKey\", function () { return $f9086e0cc03499bb$export$ceb27d5ba53e5cf8; });\n$parcel$export(module.exports, \"encrypt\", function () { return $f9086e0cc03499bb$export$5b0f6292f11d1d18; });\n$parcel$export(module.exports, \"decrypt\", function () { return $f9086e0cc03499bb$export$e85a0c9a1067c5d3; });\n\nvar $cQlYm = parcelRequire(\"cQlYm\");\nconst $f9086e0cc03499bb$var$algo = 'AES-GCM';\nconst $f9086e0cc03499bb$var$strToSha1 = {};\nconst $f9086e0cc03499bb$var$pack = (buff)=>btoa(String.fromCharCode.apply(null, new Uint8Array(buff)));\nconst $f9086e0cc03499bb$var$unpack = (packed)=>{\n    const str = atob(packed);\n    return new Uint8Array(str.length).map((_, i)=>str.charCodeAt(i)).buffer;\n};\nconst $f9086e0cc03499bb$export$5091bdda49ba90f5 = async (str)=>{\n    if ($f9086e0cc03499bb$var$strToSha1[str]) return $f9086e0cc03499bb$var$strToSha1[str];\n    const hash = Array.from(new Uint8Array(await crypto.subtle.digest('SHA-1', (0, $cQlYm.encodeBytes)(str)))).map((b)=>b.toString(36)).join('');\n    // eslint-disable-next-line require-atomic-updates\n    $f9086e0cc03499bb$var$strToSha1[str] = hash;\n    return hash;\n};\nconst $f9086e0cc03499bb$export$ceb27d5ba53e5cf8 = async (secret, appId, roomId)=>crypto.subtle.importKey('raw', await crypto.subtle.digest({\n        name: 'SHA-256'\n    }, (0, $cQlYm.encodeBytes)(`${secret}:${appId}:${roomId}`)), {\n        name: $f9086e0cc03499bb$var$algo\n    }, false, [\n        'encrypt',\n        'decrypt'\n    ]);\nconst $f9086e0cc03499bb$var$joinChar = '$';\nconst $f9086e0cc03499bb$var$ivJoinChar = ',';\nconst $f9086e0cc03499bb$export$5b0f6292f11d1d18 = async (keyP, plaintext)=>{\n    const iv = crypto.getRandomValues(new Uint8Array(16));\n    return iv.join($f9086e0cc03499bb$var$ivJoinChar) + $f9086e0cc03499bb$var$joinChar + $f9086e0cc03499bb$var$pack(await crypto.subtle.encrypt({\n        name: $f9086e0cc03499bb$var$algo,\n        iv: iv\n    }, await keyP, (0, $cQlYm.encodeBytes)(plaintext)));\n};\nconst $f9086e0cc03499bb$export$e85a0c9a1067c5d3 = async (keyP, raw)=>{\n    const [iv, c] = raw.split($f9086e0cc03499bb$var$joinChar);\n    return (0, $cQlYm.decodeBytes)(await crypto.subtle.decrypt({\n        name: $f9086e0cc03499bb$var$algo,\n        iv: new Uint8Array(iv.split($f9086e0cc03499bb$var$ivJoinChar))\n    }, await keyP, $f9086e0cc03499bb$var$unpack(c)));\n};\n\n});\nparcelRegister(\"cQlYm\", function(module, exports) {\n\n$parcel$export(module.exports, \"libName\", function () { return $959b62a819adc0d1$export$cc42576d343e0f6a; });\n$parcel$export(module.exports, \"alloc\", function () { return $959b62a819adc0d1$export$2de70f21292aac9e; });\n$parcel$export(module.exports, \"genId\", function () { return $959b62a819adc0d1$export$87d45d9755ebb726; });\n$parcel$export(module.exports, \"selfId\", function () { return $959b62a819adc0d1$export$d01767fa86c38c2d; });\n$parcel$export(module.exports, \"all\", function () { return $959b62a819adc0d1$export$84bf76cd7afc7469; });\n$parcel$export(module.exports, \"isBrowser\", function () { return $959b62a819adc0d1$export$4e09c449d6c407f7; });\n$parcel$export(module.exports, \"entries\", function () { return $959b62a819adc0d1$export$3e9f948b41964866; });\n$parcel$export(module.exports, \"fromEntries\", function () { return $959b62a819adc0d1$export$5150077fc2e7c662; });\n$parcel$export(module.exports, \"keys\", function () { return $959b62a819adc0d1$export$ed97f33186d4b816; });\n$parcel$export(module.exports, \"noOp\", function () { return $959b62a819adc0d1$export$b50b6e108474309b; });\n$parcel$export(module.exports, \"mkErr\", function () { return $959b62a819adc0d1$export$5575a5c000f2af79; });\n$parcel$export(module.exports, \"encodeBytes\", function () { return $959b62a819adc0d1$export$2589e87d78677b0d; });\n$parcel$export(module.exports, \"decodeBytes\", function () { return $959b62a819adc0d1$export$c97600adfa527f5b; });\n$parcel$export(module.exports, \"toHex\", function () { return $959b62a819adc0d1$export$7ea66e3774a60b67; });\n$parcel$export(module.exports, \"topicPath\", function () { return $959b62a819adc0d1$export$54013e572e6e896e; });\n$parcel$export(module.exports, \"getRelays\", function () { return $959b62a819adc0d1$export$37be945df5c81949; });\n$parcel$export(module.exports, \"toJson\", function () { return $959b62a819adc0d1$export$d5b7a8bf56ee1fe2; });\n$parcel$export(module.exports, \"fromJson\", function () { return $959b62a819adc0d1$export$7ae2d2a8b28a8cb8; });\n$parcel$export(module.exports, \"makeSocket\", function () { return $959b62a819adc0d1$export$62e26c4935767b5d; });\n$parcel$export(module.exports, \"socketGetter\", function () { return $959b62a819adc0d1$export$2f8cc4ea4a8a734; });\nconst $959b62a819adc0d1$export$cc42576d343e0f6a = 'Trystero';\nconst $959b62a819adc0d1$export$2de70f21292aac9e = (n, f)=>Array(n).fill().map(f);\nconst $959b62a819adc0d1$var$charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz';\nconst $959b62a819adc0d1$export$87d45d9755ebb726 = (n)=>$959b62a819adc0d1$export$2de70f21292aac9e(n, ()=>$959b62a819adc0d1$var$charSet[Math.floor(Math.random() * $959b62a819adc0d1$var$charSet.length)]).join('');\nconst $959b62a819adc0d1$export$d01767fa86c38c2d = $959b62a819adc0d1$export$87d45d9755ebb726(20);\nconst $959b62a819adc0d1$export$84bf76cd7afc7469 = Promise.all.bind(Promise);\nconst $959b62a819adc0d1$export$4e09c449d6c407f7 = typeof window !== 'undefined';\nconst { entries: $959b62a819adc0d1$export$3e9f948b41964866, fromEntries: $959b62a819adc0d1$export$5150077fc2e7c662, keys: $959b62a819adc0d1$export$ed97f33186d4b816 } = Object;\nconst $959b62a819adc0d1$export$b50b6e108474309b = ()=>{};\nconst $959b62a819adc0d1$export$5575a5c000f2af79 = (msg)=>new Error(`${$959b62a819adc0d1$export$cc42576d343e0f6a}: ${msg}`);\nconst $959b62a819adc0d1$var$encoder = new TextEncoder();\nconst $959b62a819adc0d1$var$decoder = new TextDecoder();\nconst $959b62a819adc0d1$export$2589e87d78677b0d = (txt)=>$959b62a819adc0d1$var$encoder.encode(txt);\nconst $959b62a819adc0d1$export$c97600adfa527f5b = (buffer)=>$959b62a819adc0d1$var$decoder.decode(buffer);\nconst $959b62a819adc0d1$export$7ea66e3774a60b67 = (buffer)=>buffer.reduce((a, c)=>a + c.toString(16).padStart(2, '0'), '');\nconst $959b62a819adc0d1$export$54013e572e6e896e = (...parts)=>parts.join('@');\nconst $959b62a819adc0d1$export$37be945df5c81949 = (config, defaults, defaultN)=>(config.relayUrls || defaults).slice(0, config.relayUrls ? config.relayUrls.length : config.relayRedundancy || defaultN);\nconst $959b62a819adc0d1$export$d5b7a8bf56ee1fe2 = JSON.stringify;\nconst $959b62a819adc0d1$export$7ae2d2a8b28a8cb8 = JSON.parse;\nconst $959b62a819adc0d1$var$defaultRetryMs = 3333;\nconst $959b62a819adc0d1$var$socketRetryPeriods = {};\nconst $959b62a819adc0d1$export$62e26c4935767b5d = (url, onMessage)=>{\n    const client = {};\n    const init = ()=>{\n        const socket = new WebSocket(url);\n        socket.onclose = ()=>{\n            $959b62a819adc0d1$var$socketRetryPeriods[url] ??= $959b62a819adc0d1$var$defaultRetryMs;\n            setTimeout(init, $959b62a819adc0d1$var$socketRetryPeriods[url]);\n            $959b62a819adc0d1$var$socketRetryPeriods[url] *= 2;\n        };\n        socket.onmessage = (e)=>onMessage(e.data);\n        client.socket = socket;\n        client.url = socket.url;\n        client.ready = new Promise((res)=>socket.onopen = ()=>{\n                res(client);\n                $959b62a819adc0d1$var$socketRetryPeriods[url] = $959b62a819adc0d1$var$defaultRetryMs;\n            });\n        client.send = (data)=>{\n            if (socket.readyState === 1) socket.send(data);\n        };\n    };\n    init();\n    return client;\n};\nconst $959b62a819adc0d1$export$2f8cc4ea4a8a734 = (clientMap)=>()=>$959b62a819adc0d1$export$5150077fc2e7c662($959b62a819adc0d1$export$3e9f948b41964866(clientMap).map(([url, client])=>[\n                url,\n                client.socket\n            ]));\n\n});\n\n\nparcelRegister(\"ZfjYC\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $0b819517a10e476a$export$2e2bcd8739ae039; });\n\nvar $5Y6Yt = parcelRequire(\"5Y6Yt\");\n\nvar $cQlYm = parcelRequire(\"cQlYm\");\nconst $0b819517a10e476a$var$dataEvent = 'data';\nconst $0b819517a10e476a$var$signalEvent = 'signal';\nvar $0b819517a10e476a$export$2e2bcd8739ae039 = (initiator, config)=>{\n    const peer = new (0, $5Y6Yt.default)({\n        iceServers: [\n            {\n                urls: $0b819517a10e476a$export$35d65ce76511c412\n            }\n        ],\n        ...config,\n        initiator: initiator,\n        trickle: false\n    });\n    const onData = (d)=>earlyDataBuffer.push(d);\n    let earlyDataBuffer = [];\n    peer.on($0b819517a10e476a$var$dataEvent, onData);\n    return {\n        id: peer._id,\n        created: Date.now(),\n        connection: peer._pc,\n        get channel () {\n            return peer._channel;\n        },\n        get isDead () {\n            return peer.destroyed;\n        },\n        signal: (sdp)=>new Promise((res)=>{\n                if (!initiator) peer.on($0b819517a10e476a$var$signalEvent, res);\n                peer.signal(sdp);\n            }),\n        sendData: (data)=>peer.send(data),\n        destroy: ()=>peer.destroy(),\n        setHandlers: (handlers)=>Object.entries(handlers).forEach(([event, fn])=>peer.on(event, fn)),\n        offerPromise: initiator ? new Promise((res)=>peer.on($0b819517a10e476a$var$signalEvent, res)) : Promise.resolve(),\n        addStream: (stream)=>peer.addStream(stream),\n        removeStream: (stream)=>peer.removeStream(stream),\n        addTrack: (track, stream)=>peer.addTrack(track, stream),\n        removeTrack: (track, stream)=>peer.removeTrack(track, stream),\n        replaceTrack: (oldTrack, newTrack, stream)=>peer.replaceTrack(oldTrack, newTrack, stream),\n        drainEarlyData: (f)=>{\n            peer.off($0b819517a10e476a$var$dataEvent, onData);\n            earlyDataBuffer.forEach(f);\n            earlyDataBuffer = null;\n        }\n    };\n};\nconst $0b819517a10e476a$export$35d65ce76511c412 = [\n    ...(0, $cQlYm.alloc)(5, (_, i)=>`stun:stun${i || ''}.l.google.com:19302`),\n    'stun:global.stun.twilio.com:3478'\n];\n\n});\nparcelRegister(\"5Y6Yt\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $4587f751384f4696$export$2e2bcd8739ae039; });\n/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ \nvar $2MBfS = parcelRequire(\"2MBfS\");\n\nvar $6mAaY = parcelRequire(\"6mAaY\");\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */ class $4587f751384f4696$var$Peer extends (0, $2MBfS.default) {\n    constructor(opts = {}){\n        super(opts);\n        if (!this._pc) return;\n        this.streams = opts.streams || (opts.stream ? [\n            opts.stream\n        ] : [] // support old \"stream\" option\n        );\n        this._senderMap = new Map();\n        if (this.streams) this.streams.forEach((stream)=>{\n            this.addStream(stream);\n        });\n        this._pc.ontrack = (event)=>{\n            this._onTrack(event);\n        };\n    }\n    /**\r\n   * Add a Transceiver to the connection.\r\n   * @param {String} kind\r\n   * @param {Object=} init\r\n   */ addTransceiver(kind, init) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('addTransceiver()');\n        if (this.initiator) try {\n            this._pc.addTransceiver(kind, init);\n            this._needsNegotiation();\n        } catch (err) {\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_ADD_TRANSCEIVER'));\n        }\n        else this.emit('signal', {\n            type: 'transceiverRequest',\n            transceiverRequest: {\n                kind: kind,\n                init: init\n            }\n        });\n    }\n    /**\r\n   * Add a MediaStream to the connection.\r\n   * @param {MediaStream} stream\r\n   */ addStream(stream) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('addStream()');\n        stream.getTracks().forEach((track)=>{\n            this.addTrack(track, stream);\n        });\n    }\n    /**\r\n   * Add a MediaStreamTrack to the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */ addTrack(track, stream) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('addTrack()');\n        const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n        ;\n        let sender = submap.get(stream);\n        if (!sender) {\n            sender = this._pc.addTrack(track, stream);\n            submap.set(stream, sender);\n            this._senderMap.set(track, submap);\n            this._needsNegotiation();\n        } else if (sender.removed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED');\n        else throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED');\n    }\n    /**\r\n   * Replace a MediaStreamTrack by another in the connection.\r\n   * @param {MediaStreamTrack} oldTrack\r\n   * @param {MediaStreamTrack} newTrack\r\n   * @param {MediaStream} stream\r\n   */ replaceTrack(oldTrack, newTrack, stream) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('replaceTrack()');\n        const submap = this._senderMap.get(oldTrack);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n        if (newTrack) this._senderMap.set(newTrack, submap);\n        if (sender.replaceTrack != null) sender.replaceTrack(newTrack);\n        else this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'));\n    }\n    /**\r\n   * Remove a MediaStreamTrack from the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */ removeTrack(track, stream) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('removeSender()');\n        const submap = this._senderMap.get(track);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED');\n        try {\n            sender.removed = true;\n            this._pc.removeTrack(sender);\n        } catch (err) {\n            if (err.name === 'NS_ERROR_UNEXPECTED') this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n            ;\n            else this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_REMOVE_TRACK'));\n        }\n        this._needsNegotiation();\n    }\n    /**\r\n   * Remove a MediaStream from the connection.\r\n   * @param {MediaStream} stream\r\n   */ removeStream(stream) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED');\n        this._debug('removeSenders()');\n        stream.getTracks().forEach((track)=>{\n            this.removeTrack(track, stream);\n        });\n    }\n    _requestMissingTransceivers() {\n        if (this._pc.getTransceivers) this._pc.getTransceivers().forEach((transceiver)=>{\n            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n                transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n                ;\n                this.addTransceiver(transceiver.sender.track.kind);\n            }\n        });\n    }\n    _onTrack(event) {\n        if (this.destroyed) return;\n        event.streams.forEach((eventStream)=>{\n            this._debug('on track');\n            this.emit('track', event.track, eventStream);\n            this._remoteTracks.push({\n                track: event.track,\n                stream: eventStream\n            });\n            if (this._remoteStreams.some((remoteStream)=>{\n                return remoteStream.id === eventStream.id;\n            })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n            this._remoteStreams.push(eventStream);\n            queueMicrotask(()=>{\n                this._debug('on stream');\n                this.emit('stream', eventStream) // ensure all tracks have been added\n                ;\n            });\n        });\n    }\n}\nvar $4587f751384f4696$export$2e2bcd8739ae039 = $4587f751384f4696$var$Peer;\n\n});\nparcelRegister(\"2MBfS\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $206cf6902e689423$export$2e2bcd8739ae039; });\n/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ \nvar $5tDV0 = parcelRequire(\"5tDV0\");\n\nvar $e6IBz = parcelRequire(\"e6IBz\");\n\nvar $kSdTa = parcelRequire(\"kSdTa\");\n\nvar $6mAaY = parcelRequire(\"6mAaY\");\n\nvar $4aZbe = parcelRequire(\"4aZbe\");\nconst $206cf6902e689423$var$Debug = (0, (/*@__PURE__*/$parcel$interopDefault($5tDV0)))('simple-peer');\nconst $206cf6902e689423$var$MAX_BUFFERED_AMOUNT = 65536;\nconst $206cf6902e689423$var$ICECOMPLETE_TIMEOUT = 5000;\nconst $206cf6902e689423$var$CHANNEL_CLOSING_TIMEOUT = 5000;\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction $206cf6902e689423$var$filterTrickle(sdp) {\n    return sdp.replace(/a=ice-options:trickle\\s\\n/g, '');\n}\nfunction $206cf6902e689423$var$warn(message) {\n    console.warn(message);\n}\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */ class $206cf6902e689423$var$Peer extends (0, $kSdTa.Duplex) {\n    /** @type {RTCPeerConnection} */ _pc;\n    constructor(opts){\n        opts = Object.assign({\n            allowHalfOpen: false\n        }, opts);\n        super(opts);\n        this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\n        ;\n        this._id = (0, $4aZbe.arr2hex)((0, $4aZbe.randomBytes)(4)).slice(0, 7);\n        this._debug('new peer %o', opts);\n        this.channelName = opts.initiator ? opts.channelName || (0, $4aZbe.arr2hex)((0, $4aZbe.randomBytes)(20)) : null;\n        this.initiator = opts.initiator || false;\n        this.channelConfig = opts.channelConfig || $206cf6902e689423$var$Peer.channelConfig;\n        this.channelNegotiated = this.channelConfig.negotiated;\n        this.config = Object.assign({}, $206cf6902e689423$var$Peer.config, opts.config);\n        this.offerOptions = opts.offerOptions || {};\n        this.answerOptions = opts.answerOptions || {};\n        this.sdpTransform = opts.sdpTransform || ((sdp)=>sdp);\n        this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n        this.iceCompleteTimeout = opts.iceCompleteTimeout || $206cf6902e689423$var$ICECOMPLETE_TIMEOUT;\n        this._destroying = false;\n        this._connected = false;\n        this.remoteAddress = undefined;\n        this.remoteFamily = undefined;\n        this.remotePort = undefined;\n        this.localAddress = undefined;\n        this.localFamily = undefined;\n        this.localPort = undefined;\n        if (!(0, $e6IBz.RTCPeerConnection)) {\n            if (typeof window === 'undefined') throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT');\n            else throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT');\n        }\n        this._pcReady = false;\n        this._channelReady = false;\n        this._iceComplete = false // ice candidate trickle done (got null candidate)\n        ;\n        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n        ;\n        this._channel = null;\n        this._pendingCandidates = [];\n        this._isNegotiating = false // is this peer waiting for negotiation to complete?\n        ;\n        this._firstNegotiation = true;\n        this._batchedNegotiation = false // batch synchronous negotiations\n        ;\n        this._queuedNegotiation = false // is there a queued negotiation request?\n        ;\n        this._sendersAwaitingStable = [];\n        this._closingInterval = null;\n        this._remoteTracks = [];\n        this._remoteStreams = [];\n        this._chunk = null;\n        this._cb = null;\n        this._interval = null;\n        try {\n            this._pc = new (0, $e6IBz.RTCPeerConnection)(this.config);\n        } catch (err) {\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_PC_CONSTRUCTOR'));\n            return;\n        }\n        // We prefer feature detection whenever possible, but sometimes that's not\n        // possible for certain implementations.\n        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number';\n        this._pc.oniceconnectionstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onicegatheringstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onconnectionstatechange = ()=>{\n            this._onConnectionStateChange();\n        };\n        this._pc.onsignalingstatechange = ()=>{\n            this._onSignalingStateChange();\n        };\n        this._pc.onicecandidate = (event)=>{\n            this._onIceCandidate(event);\n        };\n        // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n        if (typeof this._pc.peerIdentity === 'object') this._pc.peerIdentity.catch((err)=>{\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_PC_PEER_IDENTITY'));\n        });\n        // Other spec events, unused by this implementation:\n        // - onconnectionstatechange\n        // - onicecandidateerror\n        // - onfingerprintfailure\n        // - onnegotiationneeded\n        if (this.initiator || this.channelNegotiated) this._setupData({\n            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n        });\n        else this._pc.ondatachannel = (event)=>{\n            this._setupData(event);\n        };\n        this._debug('initial negotiation');\n        this._needsNegotiation();\n        this._onFinishBound = ()=>{\n            this._onFinish();\n        };\n        this.once('finish', this._onFinishBound);\n    }\n    get bufferSize() {\n        return this._channel && this._channel.bufferedAmount || 0;\n    }\n    // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    get connected() {\n        return this._connected && this._channel.readyState === 'open';\n    }\n    address() {\n        return {\n            port: this.localPort,\n            family: this.localFamily,\n            address: this.localAddress\n        };\n    }\n    signal(data) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED');\n        if (typeof data === 'string') try {\n            data = JSON.parse(data);\n        } catch (err) {\n            data = {};\n        }\n        this._debug('signal()');\n        if (data.renegotiate && this.initiator) {\n            this._debug('got request to renegotiate');\n            this._needsNegotiation();\n        }\n        if (data.transceiverRequest && this.initiator) {\n            this._debug('got request for transceiver');\n            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n        }\n        if (data.candidate) {\n            if (this._pc.remoteDescription && this._pc.remoteDescription.type) this._addIceCandidate(data.candidate);\n            else this._pendingCandidates.push(data.candidate);\n        }\n        if (data.sdp) this._pc.setRemoteDescription(new (0, $e6IBz.RTCSessionDescription)(data)).then(()=>{\n            if (this.destroyed) return;\n            this._pendingCandidates.forEach((candidate)=>{\n                this._addIceCandidate(candidate);\n            });\n            this._pendingCandidates = [];\n            if (this._pc.remoteDescription.type === 'offer') this._createAnswer();\n        }).catch((err)=>{\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_SET_REMOTE_DESCRIPTION'));\n        });\n        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'));\n    }\n    _addIceCandidate(candidate) {\n        const iceCandidateObj = new (0, $e6IBz.RTCIceCandidate)(candidate);\n        this._pc.addIceCandidate(iceCandidateObj).catch((err)=>{\n            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) $206cf6902e689423$var$warn('Ignoring unsupported ICE candidate.');\n            else this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_ADD_ICE_CANDIDATE'));\n        });\n    }\n    /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */ send(chunk) {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED');\n        this._channel.send(chunk);\n    }\n    _needsNegotiation() {\n        this._debug('_needsNegotiation');\n        if (this._batchedNegotiation) return; // batch synchronous renegotiations\n        this._batchedNegotiation = true;\n        queueMicrotask(()=>{\n            this._batchedNegotiation = false;\n            if (this.initiator || !this._firstNegotiation) {\n                this._debug('starting batched negotiation');\n                this.negotiate();\n            } else this._debug('non-initiator initial negotiation request discarded');\n            this._firstNegotiation = false;\n        });\n    }\n    negotiate() {\n        if (this._destroying) return;\n        if (this.destroyed) throw (0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED');\n        if (this.initiator) {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug('already negotiating, queueing');\n            } else {\n                this._debug('start negotiation');\n                setTimeout(()=>{\n                    this._createOffer();\n                }, 0);\n            }\n        } else if (this._isNegotiating) {\n            this._queuedNegotiation = true;\n            this._debug('already negotiating, queueing');\n        } else {\n            this._debug('requesting negotiation from initiator');\n            this.emit('signal', {\n                type: 'renegotiate',\n                renegotiate: true\n            });\n        }\n        this._isNegotiating = true;\n    }\n    _final(cb) {\n        if (!this._readableState.ended) this.push(null);\n        cb(null);\n    }\n    __destroy(err) {\n        this.end();\n        this._destroy(()=>{}, err);\n    }\n    _destroy(cb, err) {\n        if (this.destroyed || this._destroying) return;\n        this._destroying = true;\n        this._debug('destroying (error: %s)', err && (err.message || err));\n        setTimeout(()=>{\n            this._connected = false;\n            this._pcReady = false;\n            this._channelReady = false;\n            this._remoteTracks = null;\n            this._remoteStreams = null;\n            this._senderMap = null;\n            clearInterval(this._closingInterval);\n            this._closingInterval = null;\n            clearInterval(this._interval);\n            this._interval = null;\n            this._chunk = null;\n            this._cb = null;\n            if (this._onFinishBound) this.removeListener('finish', this._onFinishBound);\n            this._onFinishBound = null;\n            if (this._channel) {\n                try {\n                    this._channel.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._channel.onmessage = null;\n                this._channel.onopen = null;\n                this._channel.onclose = null;\n                this._channel.onerror = null;\n            }\n            if (this._pc) {\n                try {\n                    this._pc.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._pc.oniceconnectionstatechange = null;\n                this._pc.onicegatheringstatechange = null;\n                this._pc.onsignalingstatechange = null;\n                this._pc.onicecandidate = null;\n                this._pc.ontrack = null;\n                this._pc.ondatachannel = null;\n            }\n            this._pc = null;\n            this._channel = null;\n            if (err) this.emit('error', err);\n            cb();\n        }, 0);\n    }\n    _setupData(event) {\n        if (!event.channel) // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n        // which is invalid behavior. Handle it gracefully.\n        // See: https://github.com/feross/simple-peer/issues/163\n        return this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'));\n        this._channel = event.channel;\n        this._channel.binaryType = 'arraybuffer';\n        if (typeof this._channel.bufferedAmountLowThreshold === 'number') this._channel.bufferedAmountLowThreshold = $206cf6902e689423$var$MAX_BUFFERED_AMOUNT;\n        this.channelName = this._channel.label;\n        this._channel.onmessage = (event)=>{\n            this._onChannelMessage(event);\n        };\n        this._channel.onbufferedamountlow = ()=>{\n            this._onChannelBufferedAmountLow();\n        };\n        this._channel.onopen = ()=>{\n            this._onChannelOpen();\n        };\n        this._channel.onclose = ()=>{\n            this._onChannelClose();\n        };\n        this._channel.onerror = (event)=>{\n            const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_DATA_CHANNEL'));\n        };\n        // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n        let isClosing = false;\n        this._closingInterval = setInterval(()=>{\n            if (this._channel && this._channel.readyState === 'closing') {\n                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n                ;\n                isClosing = true;\n            } else isClosing = false;\n        }, $206cf6902e689423$var$CHANNEL_CLOSING_TIMEOUT);\n    }\n    _write(chunk, cb) {\n        if (this.destroyed) return cb((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'));\n        if (this._connected) {\n            try {\n                this.send(chunk);\n            } catch (err) {\n                return this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_DATA_CHANNEL'));\n            }\n            if (this._channel.bufferedAmount > $206cf6902e689423$var$MAX_BUFFERED_AMOUNT) {\n                this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n                this._cb = cb;\n            } else cb(null);\n        } else {\n            this._debug('write before connect');\n            this._chunk = chunk;\n            this._cb = cb;\n        }\n    }\n    // When stream finishes writing, close socket. Half open connections are not\n    // supported.\n    _onFinish() {\n        if (this.destroyed) return;\n        // Wait a bit before destroying so the socket flushes.\n        // TODO: is there a more reliable way to accomplish this?\n        const destroySoon = ()=>{\n            setTimeout(()=>this.__destroy(), 1000);\n        };\n        if (this._connected) destroySoon();\n        else this.once('connect', destroySoon);\n    }\n    _startIceCompleteTimeout() {\n        if (this.destroyed) return;\n        if (this._iceCompleteTimer) return;\n        this._debug('started iceComplete timeout');\n        this._iceCompleteTimer = setTimeout(()=>{\n            if (!this._iceComplete) {\n                this._iceComplete = true;\n                this._debug('iceComplete timeout completed');\n                this.emit('iceTimeout');\n                this.emit('_iceComplete');\n            }\n        }, this.iceCompleteTimeout);\n    }\n    _createOffer() {\n        if (this.destroyed) return;\n        this._pc.createOffer(this.offerOptions).then((offer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) offer.sdp = $206cf6902e689423$var$filterTrickle(offer.sdp);\n            offer.sdp = this.sdpTransform(offer.sdp);\n            const sendOffer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || offer;\n                this._debug('signal');\n                this.emit('signal', {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n            };\n            const onSuccess = ()=>{\n                this._debug('createOffer success');\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendOffer();\n                else this.once('_iceComplete', sendOffer) // wait for candidates\n                ;\n            };\n            const onError = (err)=>{\n                this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n            };\n            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_CREATE_OFFER'));\n        });\n    }\n    _createAnswer() {\n        if (this.destroyed) return;\n        this._pc.createAnswer(this.answerOptions).then((answer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) answer.sdp = $206cf6902e689423$var$filterTrickle(answer.sdp);\n            answer.sdp = this.sdpTransform(answer.sdp);\n            const sendAnswer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || answer;\n                this._debug('signal');\n                this.emit('signal', {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n                if (!this.initiator) this._requestMissingTransceivers?.();\n            };\n            const onSuccess = ()=>{\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendAnswer();\n                else this.once('_iceComplete', sendAnswer);\n            };\n            const onError = (err)=>{\n                this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_SET_LOCAL_DESCRIPTION'));\n            };\n            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_CREATE_ANSWER'));\n        });\n    }\n    _onConnectionStateChange() {\n        if (this.destroyed || this._destroying) return;\n        if (this._pc.connectionState === 'failed') this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'));\n    }\n    _onIceStateChange() {\n        if (this.destroyed) return;\n        const iceConnectionState = this._pc.iceConnectionState;\n        const iceGatheringState = this._pc.iceGatheringState;\n        this._debug('iceStateChange (connection: %s) (gathering: %s)', iceConnectionState, iceGatheringState);\n        this.emit('iceStateChange', iceConnectionState, iceGatheringState);\n        if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n            this._pcReady = true;\n            this._maybeReady();\n        }\n        if (iceConnectionState === 'failed') this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'));\n        if (iceConnectionState === 'closed') this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'));\n    }\n    getStats(cb) {\n        // statreports can come with a value array instead of properties\n        const flattenValues = (report)=>{\n            if (Object.prototype.toString.call(report.values) === '[object Array]') report.values.forEach((value)=>{\n                Object.assign(report, value);\n            });\n            return report;\n        };\n        // Promise-based getStats() (standard)\n        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) this._pc.getStats().then((res)=>{\n            const reports = [];\n            res.forEach((report)=>{\n                reports.push(flattenValues(report));\n            });\n            cb(null, reports);\n        }, (err)=>cb(err));\n        else if (this._pc.getStats.length > 0) this._pc.getStats((res)=>{\n            // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n            if (this.destroyed) return;\n            const reports = [];\n            res.result().forEach((result)=>{\n                const report = {};\n                result.names().forEach((name)=>{\n                    report[name] = result.stat(name);\n                });\n                report.id = result.id;\n                report.type = result.type;\n                report.timestamp = result.timestamp;\n                reports.push(flattenValues(report));\n            });\n            cb(null, reports);\n        }, (err)=>cb(err));\n        else cb(null, []);\n    }\n    _maybeReady() {\n        this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady);\n        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n        this._connecting = true;\n        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n        const findCandidatePair = ()=>{\n            if (this.destroyed || this._destroying) return;\n            this.getStats((err, items)=>{\n                if (this.destroyed || this._destroying) return;\n                // Treat getStats error as non-fatal. It's not essential.\n                if (err) items = [];\n                const remoteCandidates = {};\n                const localCandidates = {};\n                const candidatePairs = {};\n                let foundSelectedCandidatePair = false;\n                items.forEach((item)=>{\n                    // TODO: Once all browsers support the hyphenated stats report types, remove\n                    // the non-hypenated ones\n                    if (item.type === 'remotecandidate' || item.type === 'remote-candidate') remoteCandidates[item.id] = item;\n                    if (item.type === 'localcandidate' || item.type === 'local-candidate') localCandidates[item.id] = item;\n                    if (item.type === 'candidatepair' || item.type === 'candidate-pair') candidatePairs[item.id] = item;\n                });\n                const setSelectedCandidatePair = (selectedCandidatePair)=>{\n                    foundSelectedCandidatePair = true;\n                    let local = localCandidates[selectedCandidatePair.localCandidateId];\n                    if (local && (local.ip || local.address)) {\n                        // Spec\n                        this.localAddress = local.ip || local.address;\n                        this.localPort = Number(local.port);\n                    } else if (local && local.ipAddress) {\n                        // Firefox\n                        this.localAddress = local.ipAddress;\n                        this.localPort = Number(local.portNumber);\n                    } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n                        // TODO: remove this once Chrome 58 is released\n                        local = selectedCandidatePair.googLocalAddress.split(':');\n                        this.localAddress = local[0];\n                        this.localPort = Number(local[1]);\n                    }\n                    if (this.localAddress) this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4';\n                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n                    if (remote && (remote.ip || remote.address)) {\n                        // Spec\n                        this.remoteAddress = remote.ip || remote.address;\n                        this.remotePort = Number(remote.port);\n                    } else if (remote && remote.ipAddress) {\n                        // Firefox\n                        this.remoteAddress = remote.ipAddress;\n                        this.remotePort = Number(remote.portNumber);\n                    } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n                        // TODO: remove this once Chrome 58 is released\n                        remote = selectedCandidatePair.googRemoteAddress.split(':');\n                        this.remoteAddress = remote[0];\n                        this.remotePort = Number(remote[1]);\n                    }\n                    if (this.remoteAddress) this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4';\n                    this._debug('connect local: %s:%s remote: %s:%s', this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n                };\n                items.forEach((item)=>{\n                    // Spec-compliant\n                    if (item.type === 'transport' && item.selectedCandidatePairId) setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n                    // Old implementations\n                    if (item.type === 'googCandidatePair' && item.googActiveConnection === 'true' || (item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected) setSelectedCandidatePair(item);\n                });\n                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n                // But wait until at least 1 candidate pair is available\n                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n                    setTimeout(findCandidatePair, 100);\n                    return;\n                } else {\n                    this._connecting = false;\n                    this._connected = true;\n                }\n                if (this._chunk) {\n                    try {\n                        this.send(this._chunk);\n                    } catch (err) {\n                        return this.__destroy((0, (/*@__PURE__*/$parcel$interopDefault($6mAaY)))(err, 'ERR_DATA_CHANNEL'));\n                    }\n                    this._chunk = null;\n                    this._debug('sent chunk from \"write before connect\"');\n                    const cb = this._cb;\n                    this._cb = null;\n                    cb(null);\n                }\n                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n                // fallback to using setInterval to implement backpressure.\n                if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n                    this._interval = setInterval(()=>this._onInterval(), 150);\n                    if (this._interval.unref) this._interval.unref();\n                }\n                this._debug('connect');\n                this.emit('connect');\n            });\n        };\n        findCandidatePair();\n    }\n    _onInterval() {\n        if (!this._cb || !this._channel || this._channel.bufferedAmount > $206cf6902e689423$var$MAX_BUFFERED_AMOUNT) return;\n        this._onChannelBufferedAmountLow();\n    }\n    _onSignalingStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.signalingState === 'stable') {\n            this._isNegotiating = false;\n            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n            this._debug('flushing sender queue', this._sendersAwaitingStable);\n            this._sendersAwaitingStable.forEach((sender)=>{\n                this._pc.removeTrack(sender);\n                this._queuedNegotiation = true;\n            });\n            this._sendersAwaitingStable = [];\n            if (this._queuedNegotiation) {\n                this._debug('flushing negotiation queue');\n                this._queuedNegotiation = false;\n                this._needsNegotiation() // negotiate again\n                ;\n            } else {\n                this._debug('negotiated');\n                this.emit('negotiated');\n            }\n        }\n        this._debug('signalingStateChange %s', this._pc.signalingState);\n        this.emit('signalingStateChange', this._pc.signalingState);\n    }\n    _onIceCandidate(event) {\n        if (this.destroyed) return;\n        if (event.candidate && this.trickle) this.emit('signal', {\n            type: 'candidate',\n            candidate: {\n                candidate: event.candidate.candidate,\n                sdpMLineIndex: event.candidate.sdpMLineIndex,\n                sdpMid: event.candidate.sdpMid\n            }\n        });\n        else if (!event.candidate && !this._iceComplete) {\n            this._iceComplete = true;\n            this.emit('_iceComplete');\n        }\n        // as soon as we've received one valid candidate start timeout\n        if (event.candidate) this._startIceCompleteTimeout();\n    }\n    _onChannelMessage(event) {\n        if (this.destroyed) return;\n        let data = event.data;\n        if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n        else if (this.__objectMode === false) data = (0, $4aZbe.text2arr)(data);\n        this.push(data);\n    }\n    _onChannelBufferedAmountLow() {\n        if (this.destroyed || !this._cb) return;\n        this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount);\n        const cb = this._cb;\n        this._cb = null;\n        cb(null);\n    }\n    _onChannelOpen() {\n        if (this._connected || this.destroyed) return;\n        this._debug('on channel open');\n        this._channelReady = true;\n        this._maybeReady();\n    }\n    _onChannelClose() {\n        if (this.destroyed) return;\n        this._debug('on channel close');\n        this.__destroy();\n    }\n    _debug() {\n        const args = [].slice.call(arguments);\n        args[0] = '[' + this._id + '] ' + args[0];\n        $206cf6902e689423$var$Debug.apply(null, args);\n    }\n}\n$206cf6902e689423$var$Peer.WEBRTC_SUPPORT = !!(0, $e6IBz.RTCPeerConnection);\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */ $206cf6902e689423$var$Peer.config = {\n    iceServers: [\n        {\n            urls: [\n                'stun:stun.l.google.com:19302',\n                'stun:global.stun.twilio.com:3478'\n            ]\n        }\n    ],\n    sdpSemantics: 'unified-plan'\n};\n$206cf6902e689423$var$Peer.channelConfig = {};\nvar $206cf6902e689423$export$2e2bcd8739ae039 = $206cf6902e689423$var$Peer;\n\n});\nparcelRegister(\"5tDV0\", function(module, exports) {\n/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nvar $6qd2L = parcelRequire(\"6qd2L\");\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    '#0000CC',\n    '#0000FF',\n    '#0033CC',\n    '#0033FF',\n    '#0066CC',\n    '#0066FF',\n    '#0099CC',\n    '#0099FF',\n    '#00CC00',\n    '#00CC33',\n    '#00CC66',\n    '#00CC99',\n    '#00CCCC',\n    '#00CCFF',\n    '#3300CC',\n    '#3300FF',\n    '#3333CC',\n    '#3333FF',\n    '#3366CC',\n    '#3366FF',\n    '#3399CC',\n    '#3399FF',\n    '#33CC00',\n    '#33CC33',\n    '#33CC66',\n    '#33CC99',\n    '#33CCCC',\n    '#33CCFF',\n    '#6600CC',\n    '#6600FF',\n    '#6633CC',\n    '#6633FF',\n    '#66CC00',\n    '#66CC33',\n    '#9900CC',\n    '#9900FF',\n    '#9933CC',\n    '#9933FF',\n    '#99CC00',\n    '#99CC33',\n    '#CC0000',\n    '#CC0033',\n    '#CC0066',\n    '#CC0099',\n    '#CC00CC',\n    '#CC00FF',\n    '#CC3300',\n    '#CC3333',\n    '#CC3366',\n    '#CC3399',\n    '#CC33CC',\n    '#CC33FF',\n    '#CC6600',\n    '#CC6633',\n    '#CC9900',\n    '#CC9933',\n    '#CCCC00',\n    '#CCCC33',\n    '#FF0000',\n    '#FF0033',\n    '#FF0066',\n    '#FF0099',\n    '#FF00CC',\n    '#FF00FF',\n    '#FF3300',\n    '#FF3333',\n    '#FF3366',\n    '#FF3399',\n    '#FF33CC',\n    '#FF33FF',\n    '#FF6600',\n    '#FF6633',\n    '#FF9900',\n    '#FF9933',\n    '#FFCC00',\n    '#FFCC33'\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) return true;\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) return false;\n    let m;\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    // eslint-disable-next-line no-return-assign\n    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n    if (!this.useColors) return;\n    const c = 'color: ' + this.color;\n    args.splice(1, 0, c, 'color: inherit');\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === '%%') return;\n        index++;\n        if (match === '%c') // We only are interested in the *last* %c\n        // (the user may have provided their own)\n        lastC = index;\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) exports.storage.setItem('debug', namespaces);\n        else exports.storage.removeItem('debug');\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem('debug');\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof $6qd2L !== 'undefined' && 'env' in $6qd2L) r = undefined;\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n\nmodule.exports = (parcelRequire(\"fwp2x\"))(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return '[UnexpectedJSONParseError]: ' + error.message;\n    }\n};\n\n});\nparcelRegister(\"6qd2L\", function(module, exports) {\n// shim for using process in browser\nvar $4acf49f6c3e67aec$var$process = module.exports = {};\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\nvar $4acf49f6c3e67aec$var$cachedSetTimeout;\nvar $4acf49f6c3e67aec$var$cachedClearTimeout;\nfunction $4acf49f6c3e67aec$var$defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction $4acf49f6c3e67aec$var$defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function() {\n    try {\n        if (typeof setTimeout === 'function') $4acf49f6c3e67aec$var$cachedSetTimeout = setTimeout;\n        else $4acf49f6c3e67aec$var$cachedSetTimeout = $4acf49f6c3e67aec$var$defaultSetTimout;\n    } catch (e) {\n        $4acf49f6c3e67aec$var$cachedSetTimeout = $4acf49f6c3e67aec$var$defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') $4acf49f6c3e67aec$var$cachedClearTimeout = clearTimeout;\n        else $4acf49f6c3e67aec$var$cachedClearTimeout = $4acf49f6c3e67aec$var$defaultClearTimeout;\n    } catch (e) {\n        $4acf49f6c3e67aec$var$cachedClearTimeout = $4acf49f6c3e67aec$var$defaultClearTimeout;\n    }\n})();\nfunction $4acf49f6c3e67aec$var$runTimeout(fun) {\n    if ($4acf49f6c3e67aec$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n    // if setTimeout wasn't available but was latter defined\n    if (($4acf49f6c3e67aec$var$cachedSetTimeout === $4acf49f6c3e67aec$var$defaultSetTimout || !$4acf49f6c3e67aec$var$cachedSetTimeout) && setTimeout) {\n        $4acf49f6c3e67aec$var$cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $4acf49f6c3e67aec$var$cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return $4acf49f6c3e67aec$var$cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return $4acf49f6c3e67aec$var$cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction $4acf49f6c3e67aec$var$runClearTimeout(marker) {\n    if ($4acf49f6c3e67aec$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations\n    return clearTimeout(marker);\n    // if clearTimeout wasn't available but was latter defined\n    if (($4acf49f6c3e67aec$var$cachedClearTimeout === $4acf49f6c3e67aec$var$defaultClearTimeout || !$4acf49f6c3e67aec$var$cachedClearTimeout) && clearTimeout) {\n        $4acf49f6c3e67aec$var$cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return $4acf49f6c3e67aec$var$cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return $4acf49f6c3e67aec$var$cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return $4acf49f6c3e67aec$var$cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar $4acf49f6c3e67aec$var$queue = [];\nvar $4acf49f6c3e67aec$var$draining = false;\nvar $4acf49f6c3e67aec$var$currentQueue;\nvar $4acf49f6c3e67aec$var$queueIndex = -1;\nfunction $4acf49f6c3e67aec$var$cleanUpNextTick() {\n    if (!$4acf49f6c3e67aec$var$draining || !$4acf49f6c3e67aec$var$currentQueue) return;\n    $4acf49f6c3e67aec$var$draining = false;\n    if ($4acf49f6c3e67aec$var$currentQueue.length) $4acf49f6c3e67aec$var$queue = $4acf49f6c3e67aec$var$currentQueue.concat($4acf49f6c3e67aec$var$queue);\n    else $4acf49f6c3e67aec$var$queueIndex = -1;\n    if ($4acf49f6c3e67aec$var$queue.length) $4acf49f6c3e67aec$var$drainQueue();\n}\nfunction $4acf49f6c3e67aec$var$drainQueue() {\n    if ($4acf49f6c3e67aec$var$draining) return;\n    var timeout = $4acf49f6c3e67aec$var$runTimeout($4acf49f6c3e67aec$var$cleanUpNextTick);\n    $4acf49f6c3e67aec$var$draining = true;\n    var len = $4acf49f6c3e67aec$var$queue.length;\n    while(len){\n        $4acf49f6c3e67aec$var$currentQueue = $4acf49f6c3e67aec$var$queue;\n        $4acf49f6c3e67aec$var$queue = [];\n        while(++$4acf49f6c3e67aec$var$queueIndex < len)if ($4acf49f6c3e67aec$var$currentQueue) $4acf49f6c3e67aec$var$currentQueue[$4acf49f6c3e67aec$var$queueIndex].run();\n        $4acf49f6c3e67aec$var$queueIndex = -1;\n        len = $4acf49f6c3e67aec$var$queue.length;\n    }\n    $4acf49f6c3e67aec$var$currentQueue = null;\n    $4acf49f6c3e67aec$var$draining = false;\n    $4acf49f6c3e67aec$var$runClearTimeout(timeout);\n}\n$4acf49f6c3e67aec$var$process.nextTick = function(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n    $4acf49f6c3e67aec$var$queue.push(new $4acf49f6c3e67aec$var$Item(fun, args));\n    if ($4acf49f6c3e67aec$var$queue.length === 1 && !$4acf49f6c3e67aec$var$draining) $4acf49f6c3e67aec$var$runTimeout($4acf49f6c3e67aec$var$drainQueue);\n};\n// v8 likes predictible objects\nfunction $4acf49f6c3e67aec$var$Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\n$4acf49f6c3e67aec$var$Item.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\n$4acf49f6c3e67aec$var$process.title = 'browser';\n$4acf49f6c3e67aec$var$process.browser = true;\n$4acf49f6c3e67aec$var$process.env = {};\n$4acf49f6c3e67aec$var$process.argv = [];\n$4acf49f6c3e67aec$var$process.version = ''; // empty string to avoid regexp issues\n$4acf49f6c3e67aec$var$process.versions = {};\nfunction $4acf49f6c3e67aec$var$noop() {}\n$4acf49f6c3e67aec$var$process.on = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.addListener = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.once = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.off = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.removeListener = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.removeAllListeners = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.emit = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.prependListener = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.prependOnceListener = $4acf49f6c3e67aec$var$noop;\n$4acf49f6c3e67aec$var$process.listeners = function(name) {\n    return [];\n};\n$4acf49f6c3e67aec$var$process.binding = function(name) {\n    throw new Error('process.binding is not supported');\n};\n$4acf49f6c3e67aec$var$process.cwd = function() {\n    return '/';\n};\n$4acf49f6c3e67aec$var$process.chdir = function(dir) {\n    throw new Error('process.chdir is not supported');\n};\n$4acf49f6c3e67aec$var$process.umask = function() {\n    return 0;\n};\n\n});\n\nparcelRegister(\"fwp2x\", function(module, exports) {\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction $b4cd449a5412e50a$var$setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = (parcelRequire(\"7TIiS\"));\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) return;\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') // Anything else let's inspect with %O\n            args.unshift('%O');\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === '%%') return '%';\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === 'function') {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) return enableOverride;\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === 'function') createDebug.init(debug);\n        return debug;\n    }\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);\n        for (const ns of split)if (ns[0] === '-') createDebug.skips.push(ns.slice(1));\n        else createDebug.names.push(ns);\n    }\n    /**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */ function matchesTemplate(search, template) {\n        let searchIndex = 0;\n        let templateIndex = 0;\n        let starIndex = -1;\n        let matchIndex = 0;\n        while(searchIndex < search.length){\n            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n                // Match character or proceed with wildcard\n                if (template[templateIndex] === '*') {\n                    starIndex = templateIndex;\n                    matchIndex = searchIndex;\n                    templateIndex++; // Skip the '*'\n                } else {\n                    searchIndex++;\n                    templateIndex++;\n                }\n            } else if (starIndex !== -1) {\n                // Backtrack to the last '*' and try to match more characters\n                templateIndex = starIndex + 1;\n                matchIndex++;\n                searchIndex = matchIndex;\n            } else return false; // No match\n        }\n        // Handle trailing '*' in template\n        while(templateIndex < template.length && template[templateIndex] === '*')templateIndex++;\n        return templateIndex === template.length;\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names,\n            ...createDebug.skips.map((namespace)=>'-' + namespace)\n        ].join(',');\n        createDebug.enable('');\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        for (const skip of createDebug.skips){\n            if (matchesTemplate(name, skip)) return false;\n        }\n        for (const ns of createDebug.names){\n            if (matchesTemplate(name, ns)) return true;\n        }\n        return false;\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) return val.stack || val.message;\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = $b4cd449a5412e50a$var$setup;\n\n});\nparcelRegister(\"7TIiS\", function(module, exports) {\n/**\n * Helpers.\n */ var $5c000934e2440d9a$var$s = 1000;\nvar $5c000934e2440d9a$var$m = $5c000934e2440d9a$var$s * 60;\nvar $5c000934e2440d9a$var$h = $5c000934e2440d9a$var$m * 60;\nvar $5c000934e2440d9a$var$d = $5c000934e2440d9a$var$h * 24;\nvar $5c000934e2440d9a$var$w = $5c000934e2440d9a$var$d * 7;\nvar $5c000934e2440d9a$var$y = $5c000934e2440d9a$var$d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ module.exports = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === 'string' && val.length > 0) return $5c000934e2440d9a$var$parse(val);\n    else if (type === 'number' && isFinite(val)) return options.long ? $5c000934e2440d9a$var$fmtLong(val) : $5c000934e2440d9a$var$fmtShort(val);\n    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function $5c000934e2440d9a$var$parse(str) {\n    str = String(str);\n    if (str.length > 100) return;\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) return;\n    var n = parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n    switch(type){\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * $5c000934e2440d9a$var$y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * $5c000934e2440d9a$var$w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * $5c000934e2440d9a$var$d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * $5c000934e2440d9a$var$h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * $5c000934e2440d9a$var$m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * $5c000934e2440d9a$var$s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function $5c000934e2440d9a$var$fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= $5c000934e2440d9a$var$d) return Math.round(ms / $5c000934e2440d9a$var$d) + 'd';\n    if (msAbs >= $5c000934e2440d9a$var$h) return Math.round(ms / $5c000934e2440d9a$var$h) + 'h';\n    if (msAbs >= $5c000934e2440d9a$var$m) return Math.round(ms / $5c000934e2440d9a$var$m) + 'm';\n    if (msAbs >= $5c000934e2440d9a$var$s) return Math.round(ms / $5c000934e2440d9a$var$s) + 's';\n    return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function $5c000934e2440d9a$var$fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= $5c000934e2440d9a$var$d) return $5c000934e2440d9a$var$plural(ms, msAbs, $5c000934e2440d9a$var$d, 'day');\n    if (msAbs >= $5c000934e2440d9a$var$h) return $5c000934e2440d9a$var$plural(ms, msAbs, $5c000934e2440d9a$var$h, 'hour');\n    if (msAbs >= $5c000934e2440d9a$var$m) return $5c000934e2440d9a$var$plural(ms, msAbs, $5c000934e2440d9a$var$m, 'minute');\n    if (msAbs >= $5c000934e2440d9a$var$s) return $5c000934e2440d9a$var$plural(ms, msAbs, $5c000934e2440d9a$var$s, 'second');\n    return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */ function $5c000934e2440d9a$var$plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n});\n\n\n\nparcelRegister(\"e6IBz\", function(module, exports) {\n\n$parcel$export(module.exports, \"RTCPeerConnection\", function () { return $a45439d68055962e$export$c09fccd4ad34d599; });\n$parcel$export(module.exports, \"RTCSessionDescription\", function () { return $a45439d68055962e$export$de588b9e6d2bdb13; });\n$parcel$export(module.exports, \"RTCIceCandidate\", function () { return $a45439d68055962e$export$a7466b614c6b30d0; });\n\nconst $a45439d68055962e$var$scope = typeof window !== 'undefined' ? window : self;\nconst $a45439d68055962e$export$c09fccd4ad34d599 = $a45439d68055962e$var$scope.RTCPeerConnection || $a45439d68055962e$var$scope.mozRTCPeerConnection || $a45439d68055962e$var$scope.webkitRTCPeerConnection;\nconst $a45439d68055962e$export$de588b9e6d2bdb13 = $a45439d68055962e$var$scope.RTCSessionDescription || $a45439d68055962e$var$scope.mozRTCSessionDescription || $a45439d68055962e$var$scope.webkitRTCSessionDescription;\nconst $a45439d68055962e$export$a7466b614c6b30d0 = $a45439d68055962e$var$scope.RTCIceCandidate || $a45439d68055962e$var$scope.mozRTCIceCandidate || $a45439d68055962e$var$scope.webkitRTCIceCandidate;\nconst $a45439d68055962e$export$11dc324af62b4ec3 = $a45439d68055962e$var$scope.RTCIceTransport;\nconst $a45439d68055962e$export$a03e0d7e5900aaa4 = $a45439d68055962e$var$scope.RTCDataChannel;\nconst $a45439d68055962e$export$2f56d16bc9de58df = $a45439d68055962e$var$scope.RTCSctpTransport;\nconst $a45439d68055962e$export$aae765a6dd88b9a8 = $a45439d68055962e$var$scope.RTCDtlsTransport;\nconst $a45439d68055962e$export$6ce50a8893cc8786 = $a45439d68055962e$var$scope.RTCCertificate;\nconst $a45439d68055962e$export$502ed3215ebfcd7d = $a45439d68055962e$var$scope.MediaStream;\nconst $a45439d68055962e$export$47a09c4481afbfaa = $a45439d68055962e$var$scope.MediaStreamTrack;\nconst $a45439d68055962e$export$40731690a9592142 = $a45439d68055962e$var$scope.MediaStreamTrackEvent;\nconst $a45439d68055962e$export$d3b589450f870ec6 = $a45439d68055962e$var$scope.RTCPeerConnectionIceEvent;\nconst $a45439d68055962e$export$c5ec5e61541b8d78 = $a45439d68055962e$var$scope.RTCDataChannelEvent;\nconst $a45439d68055962e$export$95470c2d0c1d0e54 = $a45439d68055962e$var$scope.RTCTrackEvent;\nconst $a45439d68055962e$export$da0985c858f565cb = $a45439d68055962e$var$scope.RTCError;\nconst $a45439d68055962e$export$50f0fd3b2159acb6 = $a45439d68055962e$var$scope.RTCErrorEvent;\nconst $a45439d68055962e$export$67e0101499f0cbd4 = $a45439d68055962e$var$scope.RTCRtpTransceiver;\nconst $a45439d68055962e$export$345d38bb6b877191 = $a45439d68055962e$var$scope.RTCRtpReceiver;\nconst $a45439d68055962e$export$157da511dc7b80b = $a45439d68055962e$var$scope.RTCRtpSender;\n\n});\n\nparcelRegister(\"kSdTa\", function(module, exports) {\n\nvar $dG33B = parcelRequire(\"dG33B\");\nvar $f3239fcb9523168b$require$EventEmitter = $dG33B.EventEmitter;\nconst $f3239fcb9523168b$var$STREAM_DESTROYED = new Error('Stream was destroyed');\nconst $f3239fcb9523168b$var$PREMATURE_CLOSE = new Error('Premature close');\n\nvar $lb7s4 = parcelRequire(\"lb7s4\");\n\nvar $8KR6e = parcelRequire(\"8KR6e\");\n\nvar $dwlN4 = parcelRequire(\"dwlN4\");\n/* eslint-disable no-multi-spaces */ // 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst $f3239fcb9523168b$var$MAX = 536870911;\n// Shared state\nconst $f3239fcb9523168b$var$OPENING = 1;\nconst $f3239fcb9523168b$var$PREDESTROYING = 2;\nconst $f3239fcb9523168b$var$DESTROYING = 4;\nconst $f3239fcb9523168b$var$DESTROYED = 8;\nconst $f3239fcb9523168b$var$NOT_OPENING = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$OPENING;\nconst $f3239fcb9523168b$var$NOT_PREDESTROYING = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$PREDESTROYING;\n// Read state (4 bit offset from shared state)\nconst $f3239fcb9523168b$var$READ_ACTIVE = 16;\nconst $f3239fcb9523168b$var$READ_UPDATING = 32;\nconst $f3239fcb9523168b$var$READ_PRIMARY = 64;\nconst $f3239fcb9523168b$var$READ_QUEUED = 128;\nconst $f3239fcb9523168b$var$READ_RESUMED = 256;\nconst $f3239fcb9523168b$var$READ_PIPE_DRAINED = 512;\nconst $f3239fcb9523168b$var$READ_ENDING = 1024;\nconst $f3239fcb9523168b$var$READ_EMIT_DATA = 2048;\nconst $f3239fcb9523168b$var$READ_EMIT_READABLE = 4096;\nconst $f3239fcb9523168b$var$READ_EMITTED_READABLE = 8192;\nconst $f3239fcb9523168b$var$READ_DONE = 16384;\nconst $f3239fcb9523168b$var$READ_NEXT_TICK = 32768;\nconst $f3239fcb9523168b$var$READ_NEEDS_PUSH = 65536;\nconst $f3239fcb9523168b$var$READ_READ_AHEAD = 131072;\n// Combined read state\nconst $f3239fcb9523168b$var$READ_FLOWING = $f3239fcb9523168b$var$READ_RESUMED | $f3239fcb9523168b$var$READ_PIPE_DRAINED;\nconst $f3239fcb9523168b$var$READ_ACTIVE_AND_NEEDS_PUSH = $f3239fcb9523168b$var$READ_ACTIVE | $f3239fcb9523168b$var$READ_NEEDS_PUSH;\nconst $f3239fcb9523168b$var$READ_PRIMARY_AND_ACTIVE = $f3239fcb9523168b$var$READ_PRIMARY | $f3239fcb9523168b$var$READ_ACTIVE;\nconst $f3239fcb9523168b$var$READ_EMIT_READABLE_AND_QUEUED = $f3239fcb9523168b$var$READ_EMIT_READABLE | $f3239fcb9523168b$var$READ_QUEUED;\nconst $f3239fcb9523168b$var$READ_RESUMED_READ_AHEAD = $f3239fcb9523168b$var$READ_RESUMED | $f3239fcb9523168b$var$READ_READ_AHEAD;\nconst $f3239fcb9523168b$var$READ_NOT_ACTIVE = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_ACTIVE;\nconst $f3239fcb9523168b$var$READ_NON_PRIMARY = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_PRIMARY;\nconst $f3239fcb9523168b$var$READ_NON_PRIMARY_AND_PUSHED = $f3239fcb9523168b$var$MAX ^ ($f3239fcb9523168b$var$READ_PRIMARY | $f3239fcb9523168b$var$READ_NEEDS_PUSH);\nconst $f3239fcb9523168b$var$READ_PUSHED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_NEEDS_PUSH;\nconst $f3239fcb9523168b$var$READ_PAUSED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_RESUMED;\nconst $f3239fcb9523168b$var$READ_NOT_QUEUED = $f3239fcb9523168b$var$MAX ^ ($f3239fcb9523168b$var$READ_QUEUED | $f3239fcb9523168b$var$READ_EMITTED_READABLE);\nconst $f3239fcb9523168b$var$READ_NOT_ENDING = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_ENDING;\nconst $f3239fcb9523168b$var$READ_PIPE_NOT_DRAINED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_FLOWING;\nconst $f3239fcb9523168b$var$READ_NOT_NEXT_TICK = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_NEXT_TICK;\nconst $f3239fcb9523168b$var$READ_NOT_UPDATING = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_UPDATING;\nconst $f3239fcb9523168b$var$READ_NO_READ_AHEAD = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_READ_AHEAD;\nconst $f3239fcb9523168b$var$READ_PAUSED_NO_READ_AHEAD = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$READ_RESUMED_READ_AHEAD;\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst $f3239fcb9523168b$var$WRITE_ACTIVE = 262144;\nconst $f3239fcb9523168b$var$WRITE_UPDATING = 524288;\nconst $f3239fcb9523168b$var$WRITE_PRIMARY = 1048576;\nconst $f3239fcb9523168b$var$WRITE_QUEUED = 2097152;\nconst $f3239fcb9523168b$var$WRITE_UNDRAINED = 4194304;\nconst $f3239fcb9523168b$var$WRITE_DONE = 8388608;\nconst $f3239fcb9523168b$var$WRITE_EMIT_DRAIN = 16777216;\nconst $f3239fcb9523168b$var$WRITE_NEXT_TICK = 33554432;\nconst $f3239fcb9523168b$var$WRITE_WRITING = 67108864;\nconst $f3239fcb9523168b$var$WRITE_FINISHING = 134217728;\nconst $f3239fcb9523168b$var$WRITE_CORKED = 268435456;\nconst $f3239fcb9523168b$var$WRITE_NOT_ACTIVE = $f3239fcb9523168b$var$MAX ^ ($f3239fcb9523168b$var$WRITE_ACTIVE | $f3239fcb9523168b$var$WRITE_WRITING);\nconst $f3239fcb9523168b$var$WRITE_NON_PRIMARY = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_PRIMARY;\nconst $f3239fcb9523168b$var$WRITE_NOT_FINISHING = $f3239fcb9523168b$var$MAX ^ ($f3239fcb9523168b$var$WRITE_ACTIVE | $f3239fcb9523168b$var$WRITE_FINISHING);\nconst $f3239fcb9523168b$var$WRITE_DRAINED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_UNDRAINED;\nconst $f3239fcb9523168b$var$WRITE_NOT_QUEUED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_QUEUED;\nconst $f3239fcb9523168b$var$WRITE_NOT_NEXT_TICK = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_NEXT_TICK;\nconst $f3239fcb9523168b$var$WRITE_NOT_UPDATING = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_UPDATING;\nconst $f3239fcb9523168b$var$WRITE_NOT_CORKED = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$WRITE_CORKED;\n// Combined shared state\nconst $f3239fcb9523168b$var$ACTIVE = $f3239fcb9523168b$var$READ_ACTIVE | $f3239fcb9523168b$var$WRITE_ACTIVE;\nconst $f3239fcb9523168b$var$NOT_ACTIVE = $f3239fcb9523168b$var$MAX ^ $f3239fcb9523168b$var$ACTIVE;\nconst $f3239fcb9523168b$var$DONE = $f3239fcb9523168b$var$READ_DONE | $f3239fcb9523168b$var$WRITE_DONE;\nconst $f3239fcb9523168b$var$DESTROY_STATUS = $f3239fcb9523168b$var$DESTROYING | $f3239fcb9523168b$var$DESTROYED | $f3239fcb9523168b$var$PREDESTROYING;\nconst $f3239fcb9523168b$var$OPEN_STATUS = $f3239fcb9523168b$var$DESTROY_STATUS | $f3239fcb9523168b$var$OPENING;\nconst $f3239fcb9523168b$var$AUTO_DESTROY = $f3239fcb9523168b$var$DESTROY_STATUS | $f3239fcb9523168b$var$DONE;\nconst $f3239fcb9523168b$var$NON_PRIMARY = $f3239fcb9523168b$var$WRITE_NON_PRIMARY & $f3239fcb9523168b$var$READ_NON_PRIMARY;\nconst $f3239fcb9523168b$var$ACTIVE_OR_TICKING = $f3239fcb9523168b$var$WRITE_NEXT_TICK | $f3239fcb9523168b$var$READ_NEXT_TICK;\nconst $f3239fcb9523168b$var$TICKING = $f3239fcb9523168b$var$ACTIVE_OR_TICKING & $f3239fcb9523168b$var$NOT_ACTIVE;\nconst $f3239fcb9523168b$var$IS_OPENING = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$TICKING;\n// Combined shared state and read state\nconst $f3239fcb9523168b$var$READ_PRIMARY_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_ENDING | $f3239fcb9523168b$var$READ_DONE;\nconst $f3239fcb9523168b$var$READ_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_DONE | $f3239fcb9523168b$var$READ_QUEUED;\nconst $f3239fcb9523168b$var$READ_ENDING_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_ENDING | $f3239fcb9523168b$var$READ_QUEUED;\nconst $f3239fcb9523168b$var$READ_READABLE_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_EMIT_READABLE | $f3239fcb9523168b$var$READ_QUEUED | $f3239fcb9523168b$var$READ_EMITTED_READABLE;\nconst $f3239fcb9523168b$var$SHOULD_NOT_READ = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_ACTIVE | $f3239fcb9523168b$var$READ_ENDING | $f3239fcb9523168b$var$READ_DONE | $f3239fcb9523168b$var$READ_NEEDS_PUSH | $f3239fcb9523168b$var$READ_READ_AHEAD;\nconst $f3239fcb9523168b$var$READ_BACKPRESSURE_STATUS = $f3239fcb9523168b$var$DESTROY_STATUS | $f3239fcb9523168b$var$READ_ENDING | $f3239fcb9523168b$var$READ_DONE;\nconst $f3239fcb9523168b$var$READ_UPDATE_SYNC_STATUS = $f3239fcb9523168b$var$READ_UPDATING | $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_NEXT_TICK | $f3239fcb9523168b$var$READ_PRIMARY;\n// Combined write state\nconst $f3239fcb9523168b$var$WRITE_PRIMARY_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$WRITE_FINISHING | $f3239fcb9523168b$var$WRITE_DONE;\nconst $f3239fcb9523168b$var$WRITE_QUEUED_AND_UNDRAINED = $f3239fcb9523168b$var$WRITE_QUEUED | $f3239fcb9523168b$var$WRITE_UNDRAINED;\nconst $f3239fcb9523168b$var$WRITE_QUEUED_AND_ACTIVE = $f3239fcb9523168b$var$WRITE_QUEUED | $f3239fcb9523168b$var$WRITE_ACTIVE;\nconst $f3239fcb9523168b$var$WRITE_DRAIN_STATUS = $f3239fcb9523168b$var$WRITE_QUEUED | $f3239fcb9523168b$var$WRITE_UNDRAINED | $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$WRITE_ACTIVE;\nconst $f3239fcb9523168b$var$WRITE_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$WRITE_ACTIVE | $f3239fcb9523168b$var$WRITE_QUEUED | $f3239fcb9523168b$var$WRITE_CORKED;\nconst $f3239fcb9523168b$var$WRITE_PRIMARY_AND_ACTIVE = $f3239fcb9523168b$var$WRITE_PRIMARY | $f3239fcb9523168b$var$WRITE_ACTIVE;\nconst $f3239fcb9523168b$var$WRITE_ACTIVE_AND_WRITING = $f3239fcb9523168b$var$WRITE_ACTIVE | $f3239fcb9523168b$var$WRITE_WRITING;\nconst $f3239fcb9523168b$var$WRITE_FINISHING_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$WRITE_FINISHING | $f3239fcb9523168b$var$WRITE_QUEUED_AND_ACTIVE | $f3239fcb9523168b$var$WRITE_DONE;\nconst $f3239fcb9523168b$var$WRITE_BACKPRESSURE_STATUS = $f3239fcb9523168b$var$WRITE_UNDRAINED | $f3239fcb9523168b$var$DESTROY_STATUS | $f3239fcb9523168b$var$WRITE_FINISHING | $f3239fcb9523168b$var$WRITE_DONE;\nconst $f3239fcb9523168b$var$WRITE_UPDATE_SYNC_STATUS = $f3239fcb9523168b$var$WRITE_UPDATING | $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$WRITE_NEXT_TICK | $f3239fcb9523168b$var$WRITE_PRIMARY;\nconst $f3239fcb9523168b$var$WRITE_DROP_DATA = $f3239fcb9523168b$var$WRITE_FINISHING | $f3239fcb9523168b$var$WRITE_DONE | $f3239fcb9523168b$var$DESTROY_STATUS;\nconst $f3239fcb9523168b$var$DISTURBED_STATUS = $f3239fcb9523168b$var$OPEN_STATUS | $f3239fcb9523168b$var$READ_RESUMED_READ_AHEAD | $f3239fcb9523168b$var$WRITE_QUEUED;\nconst $f3239fcb9523168b$var$asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');\nclass $f3239fcb9523168b$var$WritableState {\n    constructor(stream, { highWaterMark: highWaterMark = 16384, map: map = null, mapWritable: mapWritable, byteLength: byteLength, byteLengthWritable: byteLengthWritable } = {}){\n        this.stream = stream;\n        this.queue = new $8KR6e();\n        this.highWaterMark = highWaterMark;\n        this.buffered = 0;\n        this.error = null;\n        this.pipeline = null;\n        this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n        ;\n        this.byteLength = byteLengthWritable || byteLength || $f3239fcb9523168b$var$defaultByteLength;\n        this.map = mapWritable || map;\n        this.afterWrite = $f3239fcb9523168b$var$afterWrite.bind(this);\n        this.afterUpdateNextTick = $f3239fcb9523168b$var$updateWriteNT.bind(this);\n    }\n    get ended() {\n        return (this.stream._duplexState & $f3239fcb9523168b$var$WRITE_DONE) !== 0;\n    }\n    push(data) {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_DROP_DATA) !== 0) return false;\n        if (this.map !== null) data = this.map(data);\n        this.buffered += this.byteLength(data);\n        this.queue.push(data);\n        if (this.buffered < this.highWaterMark) {\n            this.stream._duplexState |= $f3239fcb9523168b$var$WRITE_QUEUED;\n            return true;\n        }\n        this.stream._duplexState |= $f3239fcb9523168b$var$WRITE_QUEUED_AND_UNDRAINED;\n        return false;\n    }\n    shift() {\n        const data = this.queue.shift();\n        this.buffered -= this.byteLength(data);\n        if (this.buffered === 0) this.stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_QUEUED;\n        return data;\n    }\n    end(data) {\n        if (typeof data === 'function') this.stream.once('finish', data);\n        else if (data !== undefined && data !== null) this.push(data);\n        this.stream._duplexState = (this.stream._duplexState | $f3239fcb9523168b$var$WRITE_FINISHING) & $f3239fcb9523168b$var$WRITE_NON_PRIMARY;\n    }\n    autoBatch(data, cb) {\n        const buffer = [];\n        const stream = this.stream;\n        buffer.push(data);\n        while((stream._duplexState & $f3239fcb9523168b$var$WRITE_STATUS) === $f3239fcb9523168b$var$WRITE_QUEUED_AND_ACTIVE)buffer.push(stream._writableState.shift());\n        if ((stream._duplexState & $f3239fcb9523168b$var$OPEN_STATUS) !== 0) return cb(null);\n        stream._writev(buffer, cb);\n    }\n    update() {\n        const stream = this.stream;\n        stream._duplexState |= $f3239fcb9523168b$var$WRITE_UPDATING;\n        do {\n            while((stream._duplexState & $f3239fcb9523168b$var$WRITE_STATUS) === $f3239fcb9523168b$var$WRITE_QUEUED){\n                const data = this.shift();\n                stream._duplexState |= $f3239fcb9523168b$var$WRITE_ACTIVE_AND_WRITING;\n                stream._write(data, this.afterWrite);\n            }\n            if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n        }while (this.continueUpdate() === true);\n        stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_UPDATING;\n    }\n    updateNonPrimary() {\n        const stream = this.stream;\n        if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_FINISHING_STATUS) === $f3239fcb9523168b$var$WRITE_FINISHING) {\n            stream._duplexState = stream._duplexState | $f3239fcb9523168b$var$WRITE_ACTIVE;\n            stream._final($f3239fcb9523168b$var$afterFinal.bind(this));\n            return;\n        }\n        if ((stream._duplexState & $f3239fcb9523168b$var$DESTROY_STATUS) === $f3239fcb9523168b$var$DESTROYING) {\n            if ((stream._duplexState & $f3239fcb9523168b$var$ACTIVE_OR_TICKING) === 0) {\n                stream._duplexState |= $f3239fcb9523168b$var$ACTIVE;\n                stream._destroy($f3239fcb9523168b$var$afterDestroy.bind(this));\n            }\n            return;\n        }\n        if ((stream._duplexState & $f3239fcb9523168b$var$IS_OPENING) === $f3239fcb9523168b$var$OPENING) {\n            stream._duplexState = (stream._duplexState | $f3239fcb9523168b$var$ACTIVE) & $f3239fcb9523168b$var$NOT_OPENING;\n            stream._open($f3239fcb9523168b$var$afterOpen.bind(this));\n        }\n    }\n    continueUpdate() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_NEXT_TICK) === 0) return false;\n        this.stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_NEXT_TICK;\n        return true;\n    }\n    updateCallback() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_UPDATE_SYNC_STATUS) === $f3239fcb9523168b$var$WRITE_PRIMARY) this.update();\n        else this.updateNextTick();\n    }\n    updateNextTick() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_NEXT_TICK) !== 0) return;\n        this.stream._duplexState |= $f3239fcb9523168b$var$WRITE_NEXT_TICK;\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_UPDATING) === 0) $lb7s4(this.afterUpdateNextTick);\n    }\n}\nclass $f3239fcb9523168b$var$ReadableState {\n    constructor(stream, { highWaterMark: highWaterMark = 16384, map: map = null, mapReadable: mapReadable, byteLength: byteLength, byteLengthReadable: byteLengthReadable } = {}){\n        this.stream = stream;\n        this.queue = new $8KR6e();\n        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;\n        this.buffered = 0;\n        this.readAhead = highWaterMark > 0;\n        this.error = null;\n        this.pipeline = null;\n        this.byteLength = byteLengthReadable || byteLength || $f3239fcb9523168b$var$defaultByteLength;\n        this.map = mapReadable || map;\n        this.pipeTo = null;\n        this.afterRead = $f3239fcb9523168b$var$afterRead.bind(this);\n        this.afterUpdateNextTick = $f3239fcb9523168b$var$updateReadNT.bind(this);\n    }\n    get ended() {\n        return (this.stream._duplexState & $f3239fcb9523168b$var$READ_DONE) !== 0;\n    }\n    pipe(pipeTo, cb) {\n        if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');\n        if (typeof cb !== 'function') cb = null;\n        this.stream._duplexState |= $f3239fcb9523168b$var$READ_PIPE_DRAINED;\n        this.pipeTo = pipeTo;\n        this.pipeline = new $f3239fcb9523168b$var$Pipeline(this.stream, pipeTo, cb);\n        if (cb) this.stream.on('error', $f3239fcb9523168b$var$noop) // We already error handle this so supress crashes\n        ;\n        if ($f3239fcb9523168b$var$isStreamx(pipeTo)) {\n            pipeTo._writableState.pipeline = this.pipeline;\n            if (cb) pipeTo.on('error', $f3239fcb9523168b$var$noop) // We already error handle this so supress crashes\n            ;\n            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n            ;\n        } else {\n            const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);\n            const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n            ;\n            pipeTo.on('error', onerror);\n            pipeTo.on('close', onclose);\n            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));\n        }\n        pipeTo.on('drain', $f3239fcb9523168b$var$afterDrain.bind(this));\n        this.stream.emit('piping', pipeTo);\n        pipeTo.emit('pipe', this.stream);\n    }\n    push(data) {\n        const stream = this.stream;\n        if (data === null) {\n            this.highWaterMark = 0;\n            stream._duplexState = (stream._duplexState | $f3239fcb9523168b$var$READ_ENDING) & $f3239fcb9523168b$var$READ_NON_PRIMARY_AND_PUSHED;\n            return false;\n        }\n        if (this.map !== null) {\n            data = this.map(data);\n            if (data === null) {\n                stream._duplexState &= $f3239fcb9523168b$var$READ_PUSHED;\n                return this.buffered < this.highWaterMark;\n            }\n        }\n        this.buffered += this.byteLength(data);\n        this.queue.push(data);\n        stream._duplexState = (stream._duplexState | $f3239fcb9523168b$var$READ_QUEUED) & $f3239fcb9523168b$var$READ_PUSHED;\n        return this.buffered < this.highWaterMark;\n    }\n    shift() {\n        const data = this.queue.shift();\n        this.buffered -= this.byteLength(data);\n        if (this.buffered === 0) this.stream._duplexState &= $f3239fcb9523168b$var$READ_NOT_QUEUED;\n        return data;\n    }\n    unshift(data) {\n        const pending = [\n            this.map !== null ? this.map(data) : data\n        ];\n        while(this.buffered > 0)pending.push(this.shift());\n        for(let i = 0; i < pending.length - 1; i++){\n            const data = pending[i];\n            this.buffered += this.byteLength(data);\n            this.queue.push(data);\n        }\n        this.push(pending[pending.length - 1]);\n    }\n    read() {\n        const stream = this.stream;\n        if ((stream._duplexState & $f3239fcb9523168b$var$READ_STATUS) === $f3239fcb9523168b$var$READ_QUEUED) {\n            const data = this.shift();\n            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= $f3239fcb9523168b$var$READ_PIPE_NOT_DRAINED;\n            if ((stream._duplexState & $f3239fcb9523168b$var$READ_EMIT_DATA) !== 0) stream.emit('data', data);\n            return data;\n        }\n        if (this.readAhead === false) {\n            stream._duplexState |= $f3239fcb9523168b$var$READ_READ_AHEAD;\n            this.updateNextTick();\n        }\n        return null;\n    }\n    drain() {\n        const stream = this.stream;\n        while((stream._duplexState & $f3239fcb9523168b$var$READ_STATUS) === $f3239fcb9523168b$var$READ_QUEUED && (stream._duplexState & $f3239fcb9523168b$var$READ_FLOWING) !== 0){\n            const data = this.shift();\n            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= $f3239fcb9523168b$var$READ_PIPE_NOT_DRAINED;\n            if ((stream._duplexState & $f3239fcb9523168b$var$READ_EMIT_DATA) !== 0) stream.emit('data', data);\n        }\n    }\n    update() {\n        const stream = this.stream;\n        stream._duplexState |= $f3239fcb9523168b$var$READ_UPDATING;\n        do {\n            this.drain();\n            while(this.buffered < this.highWaterMark && (stream._duplexState & $f3239fcb9523168b$var$SHOULD_NOT_READ) === $f3239fcb9523168b$var$READ_READ_AHEAD){\n                stream._duplexState |= $f3239fcb9523168b$var$READ_ACTIVE_AND_NEEDS_PUSH;\n                stream._read(this.afterRead);\n                this.drain();\n            }\n            if ((stream._duplexState & $f3239fcb9523168b$var$READ_READABLE_STATUS) === $f3239fcb9523168b$var$READ_EMIT_READABLE_AND_QUEUED) {\n                stream._duplexState |= $f3239fcb9523168b$var$READ_EMITTED_READABLE;\n                stream.emit('readable');\n            }\n            if ((stream._duplexState & $f3239fcb9523168b$var$READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();\n        }while (this.continueUpdate() === true);\n        stream._duplexState &= $f3239fcb9523168b$var$READ_NOT_UPDATING;\n    }\n    updateNonPrimary() {\n        const stream = this.stream;\n        if ((stream._duplexState & $f3239fcb9523168b$var$READ_ENDING_STATUS) === $f3239fcb9523168b$var$READ_ENDING) {\n            stream._duplexState = (stream._duplexState | $f3239fcb9523168b$var$READ_DONE) & $f3239fcb9523168b$var$READ_NOT_ENDING;\n            stream.emit('end');\n            if ((stream._duplexState & $f3239fcb9523168b$var$AUTO_DESTROY) === $f3239fcb9523168b$var$DONE) stream._duplexState |= $f3239fcb9523168b$var$DESTROYING;\n            if (this.pipeTo !== null) this.pipeTo.end();\n        }\n        if ((stream._duplexState & $f3239fcb9523168b$var$DESTROY_STATUS) === $f3239fcb9523168b$var$DESTROYING) {\n            if ((stream._duplexState & $f3239fcb9523168b$var$ACTIVE_OR_TICKING) === 0) {\n                stream._duplexState |= $f3239fcb9523168b$var$ACTIVE;\n                stream._destroy($f3239fcb9523168b$var$afterDestroy.bind(this));\n            }\n            return;\n        }\n        if ((stream._duplexState & $f3239fcb9523168b$var$IS_OPENING) === $f3239fcb9523168b$var$OPENING) {\n            stream._duplexState = (stream._duplexState | $f3239fcb9523168b$var$ACTIVE) & $f3239fcb9523168b$var$NOT_OPENING;\n            stream._open($f3239fcb9523168b$var$afterOpen.bind(this));\n        }\n    }\n    continueUpdate() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$READ_NEXT_TICK) === 0) return false;\n        this.stream._duplexState &= $f3239fcb9523168b$var$READ_NOT_NEXT_TICK;\n        return true;\n    }\n    updateCallback() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$READ_UPDATE_SYNC_STATUS) === $f3239fcb9523168b$var$READ_PRIMARY) this.update();\n        else this.updateNextTick();\n    }\n    updateNextTick() {\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$READ_NEXT_TICK) !== 0) return;\n        this.stream._duplexState |= $f3239fcb9523168b$var$READ_NEXT_TICK;\n        if ((this.stream._duplexState & $f3239fcb9523168b$var$READ_UPDATING) === 0) $lb7s4(this.afterUpdateNextTick);\n    }\n}\nclass $f3239fcb9523168b$var$TransformState {\n    constructor(stream){\n        this.data = null;\n        this.afterTransform = $f3239fcb9523168b$var$afterTransform.bind(stream);\n        this.afterFinal = null;\n    }\n}\nclass $f3239fcb9523168b$var$Pipeline {\n    constructor(src, dst, cb){\n        this.from = src;\n        this.to = dst;\n        this.afterPipe = cb;\n        this.error = null;\n        this.pipeToFinished = false;\n    }\n    finished() {\n        this.pipeToFinished = true;\n    }\n    done(stream, err) {\n        if (err) this.error = err;\n        if (stream === this.to) {\n            this.to = null;\n            if (this.from !== null) {\n                if ((this.from._duplexState & $f3239fcb9523168b$var$READ_DONE) === 0 || !this.pipeToFinished) this.from.destroy(this.error || new Error('Writable stream closed prematurely'));\n                return;\n            }\n        }\n        if (stream === this.from) {\n            this.from = null;\n            if (this.to !== null) {\n                if ((stream._duplexState & $f3239fcb9523168b$var$READ_DONE) === 0) this.to.destroy(this.error || new Error('Readable stream closed before ending'));\n                return;\n            }\n        }\n        if (this.afterPipe !== null) this.afterPipe(this.error);\n        this.to = this.from = this.afterPipe = null;\n    }\n}\nfunction $f3239fcb9523168b$var$afterDrain() {\n    this.stream._duplexState |= $f3239fcb9523168b$var$READ_PIPE_DRAINED;\n    this.updateCallback();\n}\nfunction $f3239fcb9523168b$var$afterFinal(err) {\n    const stream = this.stream;\n    if (err) stream.destroy(err);\n    if ((stream._duplexState & $f3239fcb9523168b$var$DESTROY_STATUS) === 0) {\n        stream._duplexState |= $f3239fcb9523168b$var$WRITE_DONE;\n        stream.emit('finish');\n    }\n    if ((stream._duplexState & $f3239fcb9523168b$var$AUTO_DESTROY) === $f3239fcb9523168b$var$DONE) stream._duplexState |= $f3239fcb9523168b$var$DESTROYING;\n    stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_FINISHING;\n    // no need to wait the extra tick here, so we short circuit that\n    if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_UPDATING) === 0) this.update();\n    else this.updateNextTick();\n}\nfunction $f3239fcb9523168b$var$afterDestroy(err) {\n    const stream = this.stream;\n    if (!err && this.error !== $f3239fcb9523168b$var$STREAM_DESTROYED) err = this.error;\n    if (err) stream.emit('error', err);\n    stream._duplexState |= $f3239fcb9523168b$var$DESTROYED;\n    stream.emit('close');\n    const rs = stream._readableState;\n    const ws = stream._writableState;\n    if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);\n    if (ws !== null) {\n        while(ws.drains !== null && ws.drains.length > 0)ws.drains.shift().resolve(false);\n        if (ws.pipeline !== null) ws.pipeline.done(stream, err);\n    }\n}\nfunction $f3239fcb9523168b$var$afterWrite(err) {\n    const stream = this.stream;\n    if (err) stream.destroy(err);\n    stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_ACTIVE;\n    if (this.drains !== null) $f3239fcb9523168b$var$tickDrains(this.drains);\n    if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_DRAIN_STATUS) === $f3239fcb9523168b$var$WRITE_UNDRAINED) {\n        stream._duplexState &= $f3239fcb9523168b$var$WRITE_DRAINED;\n        if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_EMIT_DRAIN) === $f3239fcb9523168b$var$WRITE_EMIT_DRAIN) stream.emit('drain');\n    }\n    this.updateCallback();\n}\nfunction $f3239fcb9523168b$var$afterRead(err) {\n    if (err) this.stream.destroy(err);\n    this.stream._duplexState &= $f3239fcb9523168b$var$READ_NOT_ACTIVE;\n    if (this.readAhead === false && (this.stream._duplexState & $f3239fcb9523168b$var$READ_RESUMED) === 0) this.stream._duplexState &= $f3239fcb9523168b$var$READ_NO_READ_AHEAD;\n    this.updateCallback();\n}\nfunction $f3239fcb9523168b$var$updateReadNT() {\n    if ((this.stream._duplexState & $f3239fcb9523168b$var$READ_UPDATING) === 0) {\n        this.stream._duplexState &= $f3239fcb9523168b$var$READ_NOT_NEXT_TICK;\n        this.update();\n    }\n}\nfunction $f3239fcb9523168b$var$updateWriteNT() {\n    if ((this.stream._duplexState & $f3239fcb9523168b$var$WRITE_UPDATING) === 0) {\n        this.stream._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_NEXT_TICK;\n        this.update();\n    }\n}\nfunction $f3239fcb9523168b$var$tickDrains(drains) {\n    for(let i = 0; i < drains.length; i++)// drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n        drains.shift().resolve(true);\n        i--;\n    }\n}\nfunction $f3239fcb9523168b$var$afterOpen(err) {\n    const stream = this.stream;\n    if (err) stream.destroy(err);\n    if ((stream._duplexState & $f3239fcb9523168b$var$DESTROYING) === 0) {\n        if ((stream._duplexState & $f3239fcb9523168b$var$READ_PRIMARY_STATUS) === 0) stream._duplexState |= $f3239fcb9523168b$var$READ_PRIMARY;\n        if ((stream._duplexState & $f3239fcb9523168b$var$WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= $f3239fcb9523168b$var$WRITE_PRIMARY;\n        stream.emit('open');\n    }\n    stream._duplexState &= $f3239fcb9523168b$var$NOT_ACTIVE;\n    if (stream._writableState !== null) stream._writableState.updateCallback();\n    if (stream._readableState !== null) stream._readableState.updateCallback();\n}\nfunction $f3239fcb9523168b$var$afterTransform(err, data) {\n    if (data !== undefined && data !== null) this.push(data);\n    this._writableState.afterWrite(err);\n}\nfunction $f3239fcb9523168b$var$newListener(name) {\n    if (this._readableState !== null) {\n        if (name === 'data') {\n            this._duplexState |= $f3239fcb9523168b$var$READ_EMIT_DATA | $f3239fcb9523168b$var$READ_RESUMED_READ_AHEAD;\n            this._readableState.updateNextTick();\n        }\n        if (name === 'readable') {\n            this._duplexState |= $f3239fcb9523168b$var$READ_EMIT_READABLE;\n            this._readableState.updateNextTick();\n        }\n    }\n    if (this._writableState !== null) {\n        if (name === 'drain') {\n            this._duplexState |= $f3239fcb9523168b$var$WRITE_EMIT_DRAIN;\n            this._writableState.updateNextTick();\n        }\n    }\n}\nclass $f3239fcb9523168b$var$Stream extends $f3239fcb9523168b$require$EventEmitter {\n    constructor(opts){\n        super();\n        this._duplexState = 0;\n        this._readableState = null;\n        this._writableState = null;\n        if (opts) {\n            if (opts.open) this._open = opts.open;\n            if (opts.destroy) this._destroy = opts.destroy;\n            if (opts.predestroy) this._predestroy = opts.predestroy;\n            if (opts.signal) opts.signal.addEventListener('abort', $f3239fcb9523168b$var$abort.bind(this));\n        }\n        this.on('newListener', $f3239fcb9523168b$var$newListener);\n    }\n    _open(cb) {\n        cb(null);\n    }\n    _destroy(cb) {\n        cb(null);\n    }\n    _predestroy() {\n    // does nothing\n    }\n    get readable() {\n        return this._readableState !== null ? true : undefined;\n    }\n    get writable() {\n        return this._writableState !== null ? true : undefined;\n    }\n    get destroyed() {\n        return (this._duplexState & $f3239fcb9523168b$var$DESTROYED) !== 0;\n    }\n    get destroying() {\n        return (this._duplexState & $f3239fcb9523168b$var$DESTROY_STATUS) !== 0;\n    }\n    destroy(err) {\n        if ((this._duplexState & $f3239fcb9523168b$var$DESTROY_STATUS) === 0) {\n            if (!err) err = $f3239fcb9523168b$var$STREAM_DESTROYED;\n            this._duplexState = (this._duplexState | $f3239fcb9523168b$var$DESTROYING) & $f3239fcb9523168b$var$NON_PRIMARY;\n            if (this._readableState !== null) {\n                this._readableState.highWaterMark = 0;\n                this._readableState.error = err;\n            }\n            if (this._writableState !== null) {\n                this._writableState.highWaterMark = 0;\n                this._writableState.error = err;\n            }\n            this._duplexState |= $f3239fcb9523168b$var$PREDESTROYING;\n            this._predestroy();\n            this._duplexState &= $f3239fcb9523168b$var$NOT_PREDESTROYING;\n            if (this._readableState !== null) this._readableState.updateNextTick();\n            if (this._writableState !== null) this._writableState.updateNextTick();\n        }\n    }\n}\nclass $f3239fcb9523168b$var$Readable extends $f3239fcb9523168b$var$Stream {\n    constructor(opts){\n        super(opts);\n        this._duplexState |= $f3239fcb9523168b$var$OPENING | $f3239fcb9523168b$var$WRITE_DONE | $f3239fcb9523168b$var$READ_READ_AHEAD;\n        this._readableState = new $f3239fcb9523168b$var$ReadableState(this, opts);\n        if (opts) {\n            if (this._readableState.readAhead === false) this._duplexState &= $f3239fcb9523168b$var$READ_NO_READ_AHEAD;\n            if (opts.read) this._read = opts.read;\n            if (opts.eagerOpen) this._readableState.updateNextTick();\n            if (opts.encoding) this.setEncoding(opts.encoding);\n        }\n    }\n    setEncoding(encoding) {\n        const dec = new $dwlN4(encoding);\n        const map = this._readableState.map || $f3239fcb9523168b$var$echo;\n        this._readableState.map = mapOrSkip;\n        return this;\n        function mapOrSkip(data) {\n            const next = dec.push(data);\n            return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);\n        }\n    }\n    _read(cb) {\n        cb(null);\n    }\n    pipe(dest, cb) {\n        this._readableState.updateNextTick();\n        this._readableState.pipe(dest, cb);\n        return dest;\n    }\n    read() {\n        this._readableState.updateNextTick();\n        return this._readableState.read();\n    }\n    push(data) {\n        this._readableState.updateNextTick();\n        return this._readableState.push(data);\n    }\n    unshift(data) {\n        this._readableState.updateNextTick();\n        return this._readableState.unshift(data);\n    }\n    resume() {\n        this._duplexState |= $f3239fcb9523168b$var$READ_RESUMED_READ_AHEAD;\n        this._readableState.updateNextTick();\n        return this;\n    }\n    pause() {\n        this._duplexState &= this._readableState.readAhead === false ? $f3239fcb9523168b$var$READ_PAUSED_NO_READ_AHEAD : $f3239fcb9523168b$var$READ_PAUSED;\n        return this;\n    }\n    static _fromAsyncIterator(ite, opts) {\n        let destroy;\n        const rs = new $f3239fcb9523168b$var$Readable({\n            ...opts,\n            read (cb) {\n                ite.next().then(push).then(cb.bind(null, null)).catch(cb);\n            },\n            predestroy () {\n                destroy = ite.return();\n            },\n            destroy (cb) {\n                if (!destroy) return cb(null);\n                destroy.then(cb.bind(null, null)).catch(cb);\n            }\n        });\n        return rs;\n        function push(data) {\n            if (data.done) rs.push(null);\n            else rs.push(data.value);\n        }\n    }\n    static from(data, opts) {\n        if ($f3239fcb9523168b$var$isReadStreamx(data)) return data;\n        if (data[$f3239fcb9523168b$var$asyncIterator]) return this._fromAsyncIterator(data[$f3239fcb9523168b$var$asyncIterator](), opts);\n        if (!Array.isArray(data)) data = data === undefined ? [] : [\n            data\n        ];\n        let i = 0;\n        return new $f3239fcb9523168b$var$Readable({\n            ...opts,\n            read (cb) {\n                this.push(i === data.length ? null : data[i++]);\n                cb(null);\n            }\n        });\n    }\n    static isBackpressured(rs) {\n        return (rs._duplexState & $f3239fcb9523168b$var$READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;\n    }\n    static isPaused(rs) {\n        return (rs._duplexState & $f3239fcb9523168b$var$READ_RESUMED) === 0;\n    }\n    [$f3239fcb9523168b$var$asyncIterator]() {\n        const stream = this;\n        let error = null;\n        let promiseResolve = null;\n        let promiseReject = null;\n        this.on('error', (err)=>{\n            error = err;\n        });\n        this.on('readable', onreadable);\n        this.on('close', onclose);\n        return {\n            [$f3239fcb9523168b$var$asyncIterator] () {\n                return this;\n            },\n            next () {\n                return new Promise(function(resolve, reject) {\n                    promiseResolve = resolve;\n                    promiseReject = reject;\n                    const data = stream.read();\n                    if (data !== null) ondata(data);\n                    else if ((stream._duplexState & $f3239fcb9523168b$var$DESTROYED) !== 0) ondata(null);\n                });\n            },\n            return () {\n                return destroy(null);\n            },\n            throw (err) {\n                return destroy(err);\n            }\n        };\n        function onreadable() {\n            if (promiseResolve !== null) ondata(stream.read());\n        }\n        function onclose() {\n            if (promiseResolve !== null) ondata(null);\n        }\n        function ondata(data) {\n            if (promiseReject === null) return;\n            if (error) promiseReject(error);\n            else if (data === null && (stream._duplexState & $f3239fcb9523168b$var$READ_DONE) === 0) promiseReject($f3239fcb9523168b$var$STREAM_DESTROYED);\n            else promiseResolve({\n                value: data,\n                done: data === null\n            });\n            promiseReject = promiseResolve = null;\n        }\n        function destroy(err) {\n            stream.destroy(err);\n            return new Promise((resolve, reject)=>{\n                if (stream._duplexState & $f3239fcb9523168b$var$DESTROYED) return resolve({\n                    value: undefined,\n                    done: true\n                });\n                stream.once('close', function() {\n                    if (err) reject(err);\n                    else resolve({\n                        value: undefined,\n                        done: true\n                    });\n                });\n            });\n        }\n    }\n}\nclass $f3239fcb9523168b$var$Writable extends $f3239fcb9523168b$var$Stream {\n    constructor(opts){\n        super(opts);\n        this._duplexState |= $f3239fcb9523168b$var$OPENING | $f3239fcb9523168b$var$READ_DONE;\n        this._writableState = new $f3239fcb9523168b$var$WritableState(this, opts);\n        if (opts) {\n            if (opts.writev) this._writev = opts.writev;\n            if (opts.write) this._write = opts.write;\n            if (opts.final) this._final = opts.final;\n            if (opts.eagerOpen) this._writableState.updateNextTick();\n        }\n    }\n    cork() {\n        this._duplexState |= $f3239fcb9523168b$var$WRITE_CORKED;\n    }\n    uncork() {\n        this._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_CORKED;\n        this._writableState.updateNextTick();\n    }\n    _writev(batch, cb) {\n        cb(null);\n    }\n    _write(data, cb) {\n        this._writableState.autoBatch(data, cb);\n    }\n    _final(cb) {\n        cb(null);\n    }\n    static isBackpressured(ws) {\n        return (ws._duplexState & $f3239fcb9523168b$var$WRITE_BACKPRESSURE_STATUS) !== 0;\n    }\n    static drained(ws) {\n        if (ws.destroyed) return Promise.resolve(false);\n        const state = ws._writableState;\n        const pending = $f3239fcb9523168b$var$isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;\n        const writes = pending + (ws._duplexState & $f3239fcb9523168b$var$WRITE_WRITING ? 1 : 0);\n        if (writes === 0) return Promise.resolve(true);\n        if (state.drains === null) state.drains = [];\n        return new Promise((resolve)=>{\n            state.drains.push({\n                writes: writes,\n                resolve: resolve\n            });\n        });\n    }\n    write(data) {\n        this._writableState.updateNextTick();\n        return this._writableState.push(data);\n    }\n    end(data) {\n        this._writableState.updateNextTick();\n        this._writableState.end(data);\n        return this;\n    }\n}\nclass $f3239fcb9523168b$var$Duplex extends $f3239fcb9523168b$var$Readable {\n    constructor(opts){\n        super(opts);\n        this._duplexState = $f3239fcb9523168b$var$OPENING | this._duplexState & $f3239fcb9523168b$var$READ_READ_AHEAD;\n        this._writableState = new $f3239fcb9523168b$var$WritableState(this, opts);\n        if (opts) {\n            if (opts.writev) this._writev = opts.writev;\n            if (opts.write) this._write = opts.write;\n            if (opts.final) this._final = opts.final;\n        }\n    }\n    cork() {\n        this._duplexState |= $f3239fcb9523168b$var$WRITE_CORKED;\n    }\n    uncork() {\n        this._duplexState &= $f3239fcb9523168b$var$WRITE_NOT_CORKED;\n        this._writableState.updateNextTick();\n    }\n    _writev(batch, cb) {\n        cb(null);\n    }\n    _write(data, cb) {\n        this._writableState.autoBatch(data, cb);\n    }\n    _final(cb) {\n        cb(null);\n    }\n    write(data) {\n        this._writableState.updateNextTick();\n        return this._writableState.push(data);\n    }\n    end(data) {\n        this._writableState.updateNextTick();\n        this._writableState.end(data);\n        return this;\n    }\n}\nclass $f3239fcb9523168b$var$Transform extends $f3239fcb9523168b$var$Duplex {\n    constructor(opts){\n        super(opts);\n        this._transformState = new $f3239fcb9523168b$var$TransformState(this);\n        if (opts) {\n            if (opts.transform) this._transform = opts.transform;\n            if (opts.flush) this._flush = opts.flush;\n        }\n    }\n    _write(data, cb) {\n        if (this._readableState.buffered >= this._readableState.highWaterMark) this._transformState.data = data;\n        else this._transform(data, this._transformState.afterTransform);\n    }\n    _read(cb) {\n        if (this._transformState.data !== null) {\n            const data = this._transformState.data;\n            this._transformState.data = null;\n            cb(null);\n            this._transform(data, this._transformState.afterTransform);\n        } else cb(null);\n    }\n    destroy(err) {\n        super.destroy(err);\n        if (this._transformState.data !== null) {\n            this._transformState.data = null;\n            this._transformState.afterTransform();\n        }\n    }\n    _transform(data, cb) {\n        cb(null, data);\n    }\n    _flush(cb) {\n        cb(null);\n    }\n    _final(cb) {\n        this._transformState.afterFinal = cb;\n        this._flush($f3239fcb9523168b$var$transformAfterFlush.bind(this));\n    }\n}\nclass $f3239fcb9523168b$var$PassThrough extends $f3239fcb9523168b$var$Transform {\n}\nfunction $f3239fcb9523168b$var$transformAfterFlush(err, data) {\n    const cb = this._transformState.afterFinal;\n    if (err) return cb(err);\n    if (data !== null && data !== undefined) this.push(data);\n    this.push(null);\n    cb(null);\n}\nfunction $f3239fcb9523168b$var$pipelinePromise(...streams) {\n    return new Promise((resolve, reject)=>{\n        return $f3239fcb9523168b$var$pipeline(...streams, (err)=>{\n            if (err) return reject(err);\n            resolve();\n        });\n    });\n}\nfunction $f3239fcb9523168b$var$pipeline(stream, ...streams) {\n    const all = Array.isArray(stream) ? [\n        ...stream,\n        ...streams\n    ] : [\n        stream,\n        ...streams\n    ];\n    const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;\n    if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');\n    let src = all[0];\n    let dest = null;\n    let error = null;\n    for(let i = 1; i < all.length; i++){\n        dest = all[i];\n        if ($f3239fcb9523168b$var$isStreamx(src)) src.pipe(dest, onerror);\n        else {\n            errorHandle(src, true, i > 1, onerror);\n            src.pipe(dest);\n        }\n        src = dest;\n    }\n    if (done) {\n        let fin = false;\n        const autoDestroy = $f3239fcb9523168b$var$isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);\n        dest.on('error', (err)=>{\n            if (error === null) error = err;\n        });\n        dest.on('finish', ()=>{\n            fin = true;\n            if (!autoDestroy) done(error);\n        });\n        if (autoDestroy) dest.on('close', ()=>done(error || (fin ? null : $f3239fcb9523168b$var$PREMATURE_CLOSE)));\n    }\n    return dest;\n    function errorHandle(s, rd, wr, onerror) {\n        s.on('error', onerror);\n        s.on('close', onclose);\n        function onclose() {\n            if (rd && s._readableState && !s._readableState.ended) return onerror($f3239fcb9523168b$var$PREMATURE_CLOSE);\n            if (wr && s._writableState && !s._writableState.ended) return onerror($f3239fcb9523168b$var$PREMATURE_CLOSE);\n        }\n    }\n    function onerror(err) {\n        if (!err || error) return;\n        error = err;\n        for (const s of all)s.destroy(err);\n    }\n}\nfunction $f3239fcb9523168b$var$echo(s) {\n    return s;\n}\nfunction $f3239fcb9523168b$var$isStream(stream) {\n    return !!stream._readableState || !!stream._writableState;\n}\nfunction $f3239fcb9523168b$var$isStreamx(stream) {\n    return typeof stream._duplexState === 'number' && $f3239fcb9523168b$var$isStream(stream);\n}\nfunction $f3239fcb9523168b$var$isEnded(stream) {\n    return !!stream._readableState && stream._readableState.ended;\n}\nfunction $f3239fcb9523168b$var$isFinished(stream) {\n    return !!stream._writableState && stream._writableState.ended;\n}\nfunction $f3239fcb9523168b$var$getStreamError(stream, opts = {}) {\n    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;\n    // avoid implicit errors by default\n    return !opts.all && err === $f3239fcb9523168b$var$STREAM_DESTROYED ? null : err;\n}\nfunction $f3239fcb9523168b$var$isReadStreamx(stream) {\n    return $f3239fcb9523168b$var$isStreamx(stream) && stream.readable;\n}\nfunction $f3239fcb9523168b$var$isDisturbed(stream) {\n    return (stream._duplexState & $f3239fcb9523168b$var$DISTURBED_STATUS) !== $f3239fcb9523168b$var$OPENING;\n}\nfunction $f3239fcb9523168b$var$isTypedArray(data) {\n    return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';\n}\nfunction $f3239fcb9523168b$var$defaultByteLength(data) {\n    return $f3239fcb9523168b$var$isTypedArray(data) ? data.byteLength : 1024;\n}\nfunction $f3239fcb9523168b$var$noop() {}\nfunction $f3239fcb9523168b$var$abort() {\n    this.destroy(new Error('Stream aborted.'));\n}\nfunction $f3239fcb9523168b$var$isWritev(s) {\n    return s._writev !== $f3239fcb9523168b$var$Writable.prototype._writev && s._writev !== $f3239fcb9523168b$var$Duplex.prototype._writev;\n}\nmodule.exports = {\n    pipeline: $f3239fcb9523168b$var$pipeline,\n    pipelinePromise: $f3239fcb9523168b$var$pipelinePromise,\n    isStream: $f3239fcb9523168b$var$isStream,\n    isStreamx: $f3239fcb9523168b$var$isStreamx,\n    isDisturbed: $f3239fcb9523168b$var$isDisturbed,\n    isEnded: $f3239fcb9523168b$var$isEnded,\n    isFinished: $f3239fcb9523168b$var$isFinished,\n    getStreamError: $f3239fcb9523168b$var$getStreamError,\n    Stream: $f3239fcb9523168b$var$Stream,\n    Writable: $f3239fcb9523168b$var$Writable,\n    Readable: $f3239fcb9523168b$var$Readable,\n    Duplex: $f3239fcb9523168b$var$Duplex,\n    Transform: $f3239fcb9523168b$var$Transform,\n    PassThrough: // Export PassThrough for compatibility with Node.js core's stream module\n    $f3239fcb9523168b$var$PassThrough\n};\n\n});\nparcelRegister(\"dG33B\", function(module, exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\nvar $9f5191ad6e142a03$var$R = typeof Reflect === 'object' ? Reflect : null;\nvar $9f5191ad6e142a03$var$ReflectApply = $9f5191ad6e142a03$var$R && typeof $9f5191ad6e142a03$var$R.apply === 'function' ? $9f5191ad6e142a03$var$R.apply : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n};\nvar $9f5191ad6e142a03$var$ReflectOwnKeys;\nif ($9f5191ad6e142a03$var$R && typeof $9f5191ad6e142a03$var$R.ownKeys === 'function') $9f5191ad6e142a03$var$ReflectOwnKeys = $9f5191ad6e142a03$var$R.ownKeys;\nelse if (Object.getOwnPropertySymbols) $9f5191ad6e142a03$var$ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n};\nelse $9f5191ad6e142a03$var$ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n};\nfunction $9f5191ad6e142a03$var$ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n}\nvar $9f5191ad6e142a03$var$NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n    return value !== value;\n};\nfunction $9f5191ad6e142a03$var$EventEmitter() {\n    $9f5191ad6e142a03$var$EventEmitter.init.call(this);\n}\nmodule.exports = $9f5191ad6e142a03$var$EventEmitter;\nmodule.exports.once = $9f5191ad6e142a03$var$once;\n// Backwards-compat with node 0.10.x\n$9f5191ad6e142a03$var$EventEmitter.EventEmitter = $9f5191ad6e142a03$var$EventEmitter;\n$9f5191ad6e142a03$var$EventEmitter.prototype._events = undefined;\n$9f5191ad6e142a03$var$EventEmitter.prototype._eventsCount = 0;\n$9f5191ad6e142a03$var$EventEmitter.prototype._maxListeners = undefined;\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar $9f5191ad6e142a03$var$defaultMaxListeners = 10;\nfunction $9f5191ad6e142a03$var$checkListener(listener) {\n    if (typeof listener !== 'function') throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n}\nObject.defineProperty($9f5191ad6e142a03$var$EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n        return $9f5191ad6e142a03$var$defaultMaxListeners;\n    },\n    set: function(arg) {\n        if (typeof arg !== 'number' || arg < 0 || $9f5191ad6e142a03$var$NumberIsNaN(arg)) throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n        $9f5191ad6e142a03$var$defaultMaxListeners = arg;\n    }\n});\n$9f5191ad6e142a03$var$EventEmitter.init = function() {\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || undefined;\n};\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n$9f5191ad6e142a03$var$EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== 'number' || n < 0 || $9f5191ad6e142a03$var$NumberIsNaN(n)) throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n    this._maxListeners = n;\n    return this;\n};\nfunction $9f5191ad6e142a03$var$_getMaxListeners(that) {\n    if (that._maxListeners === undefined) return $9f5191ad6e142a03$var$EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n}\n$9f5191ad6e142a03$var$EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return $9f5191ad6e142a03$var$_getMaxListeners(this);\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.emit = function emit(type) {\n    var args = [];\n    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n    var doError = type === 'error';\n    var events = this._events;\n    if (events !== undefined) doError = doError && events.error === undefined;\n    else if (!doError) return false;\n    // If there is no 'error' event listener then throw.\n    if (doError) {\n        var er;\n        if (args.length > 0) er = args[0];\n        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n        // At least give some kind of context to the user\n        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n        err.context = er;\n        throw err; // Unhandled 'error' event\n    }\n    var handler = events[type];\n    if (handler === undefined) return false;\n    if (typeof handler === 'function') $9f5191ad6e142a03$var$ReflectApply(handler, this, args);\n    else {\n        var len = handler.length;\n        var listeners = $9f5191ad6e142a03$var$arrayClone(handler, len);\n        for(var i = 0; i < len; ++i)$9f5191ad6e142a03$var$ReflectApply(listeners[i], this, args);\n    }\n    return true;\n};\nfunction $9f5191ad6e142a03$var$_addListener(target, type, listener, prepend) {\n    var m;\n    var events;\n    var existing;\n    $9f5191ad6e142a03$var$checkListener(listener);\n    events = target._events;\n    if (events === undefined) {\n        events = target._events = Object.create(null);\n        target._eventsCount = 0;\n    } else {\n        // To avoid recursion in the case that type === \"newListener\"! Before\n        // adding it to the listeners, first emit \"newListener\".\n        if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener);\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n        }\n        existing = events[type];\n    }\n    if (existing === undefined) {\n        // Optimize the case of one listener. Don't need the extra array object.\n        existing = events[type] = listener;\n        ++target._eventsCount;\n    } else {\n        if (typeof existing === 'function') // Adding the second element, need to change to array.\n        existing = events[type] = prepend ? [\n            listener,\n            existing\n        ] : [\n            existing,\n            listener\n        ];\n        else if (prepend) existing.unshift(listener);\n        else existing.push(listener);\n        // Check for listener leak\n        m = $9f5191ad6e142a03$var$_getMaxListeners(target);\n        if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true;\n            // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            $9f5191ad6e142a03$var$ProcessEmitWarning(w);\n        }\n    }\n    return target;\n}\n$9f5191ad6e142a03$var$EventEmitter.prototype.addListener = function addListener(type, listener) {\n    return $9f5191ad6e142a03$var$_addListener(this, type, listener, false);\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.on = $9f5191ad6e142a03$var$EventEmitter.prototype.addListener;\n$9f5191ad6e142a03$var$EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n    return $9f5191ad6e142a03$var$_addListener(this, type, listener, true);\n};\nfunction $9f5191ad6e142a03$var$onceWrapper() {\n    if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0) return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n    }\n}\nfunction $9f5191ad6e142a03$var$_onceWrap(target, type, listener) {\n    var state = {\n        fired: false,\n        wrapFn: undefined,\n        target: target,\n        type: type,\n        listener: listener\n    };\n    var wrapped = $9f5191ad6e142a03$var$onceWrapper.bind(state);\n    wrapped.listener = listener;\n    state.wrapFn = wrapped;\n    return wrapped;\n}\n$9f5191ad6e142a03$var$EventEmitter.prototype.once = function once(type, listener) {\n    $9f5191ad6e142a03$var$checkListener(listener);\n    this.on(type, $9f5191ad6e142a03$var$_onceWrap(this, type, listener));\n    return this;\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n    $9f5191ad6e142a03$var$checkListener(listener);\n    this.prependListener(type, $9f5191ad6e142a03$var$_onceWrap(this, type, listener));\n    return this;\n};\n// Emits a 'removeListener' event if and only if the listener was removed.\n$9f5191ad6e142a03$var$EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n    var list, events, position, i, originalListener;\n    $9f5191ad6e142a03$var$checkListener(listener);\n    events = this._events;\n    if (events === undefined) return this;\n    list = events[type];\n    if (list === undefined) return this;\n    if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0) this._events = Object.create(null);\n        else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n        }\n    } else if (typeof list !== 'function') {\n        position = -1;\n        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n        }\n        if (position < 0) return this;\n        if (position === 0) list.shift();\n        else $9f5191ad6e142a03$var$spliceOne(list, position);\n        if (list.length === 1) events[type] = list[0];\n        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n    }\n    return this;\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.off = $9f5191ad6e142a03$var$EventEmitter.prototype.removeListener;\n$9f5191ad6e142a03$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n    var listeners, events, i;\n    events = this._events;\n    if (events === undefined) return this;\n    // not listening for removeListener, no need to emit\n    if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else delete events[type];\n        }\n        return this;\n    }\n    // emit removeListener for all listeners on all events\n    if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for(i = 0; i < keys.length; ++i){\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n    }\n    listeners = events[type];\n    if (typeof listeners === 'function') this.removeListener(type, listeners);\n    else if (listeners !== undefined) // LIFO order\n    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);\n    return this;\n};\nfunction $9f5191ad6e142a03$var$_listeners(target, type, unwrap) {\n    var events = target._events;\n    if (events === undefined) return [];\n    var evlistener = events[type];\n    if (evlistener === undefined) return [];\n    if (typeof evlistener === 'function') return unwrap ? [\n        evlistener.listener || evlistener\n    ] : [\n        evlistener\n    ];\n    return unwrap ? $9f5191ad6e142a03$var$unwrapListeners(evlistener) : $9f5191ad6e142a03$var$arrayClone(evlistener, evlistener.length);\n}\n$9f5191ad6e142a03$var$EventEmitter.prototype.listeners = function listeners(type) {\n    return $9f5191ad6e142a03$var$_listeners(this, type, true);\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.rawListeners = function rawListeners(type) {\n    return $9f5191ad6e142a03$var$_listeners(this, type, false);\n};\n$9f5191ad6e142a03$var$EventEmitter.listenerCount = function(emitter, type) {\n    if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type);\n    else return $9f5191ad6e142a03$var$listenerCount.call(emitter, type);\n};\n$9f5191ad6e142a03$var$EventEmitter.prototype.listenerCount = $9f5191ad6e142a03$var$listenerCount;\nfunction $9f5191ad6e142a03$var$listenerCount(type) {\n    var events = this._events;\n    if (events !== undefined) {\n        var evlistener = events[type];\n        if (typeof evlistener === 'function') return 1;\n        else if (evlistener !== undefined) return evlistener.length;\n    }\n    return 0;\n}\n$9f5191ad6e142a03$var$EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? $9f5191ad6e142a03$var$ReflectOwnKeys(this._events) : [];\n};\nfunction $9f5191ad6e142a03$var$arrayClone(arr, n) {\n    var copy = new Array(n);\n    for(var i = 0; i < n; ++i)copy[i] = arr[i];\n    return copy;\n}\nfunction $9f5191ad6e142a03$var$spliceOne(list, index) {\n    for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n    list.pop();\n}\nfunction $9f5191ad6e142a03$var$unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];\n    return ret;\n}\nfunction $9f5191ad6e142a03$var$once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n        function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n        }\n        function resolver() {\n            if (typeof emitter.removeListener === 'function') emitter.removeListener('error', errorListener);\n            resolve([].slice.call(arguments));\n        }\n        $9f5191ad6e142a03$var$eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n        });\n        if (name !== 'error') $9f5191ad6e142a03$var$addErrorHandlerIfEventEmitter(emitter, errorListener, {\n            once: true\n        });\n    });\n}\nfunction $9f5191ad6e142a03$var$addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === 'function') $9f5191ad6e142a03$var$eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n}\nfunction $9f5191ad6e142a03$var$eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === 'function') {\n        if (flags.once) emitter.once(name, listener);\n        else emitter.on(name, listener);\n    } else if (typeof emitter.addEventListener === 'function') // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n        // IE does not have builtin `{ once: true }` support so we\n        // have to do it manually.\n        if (flags.once) emitter.removeEventListener(name, wrapListener);\n        listener(arg);\n    });\n    else throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n}\n\n});\n\nparcelRegister(\"lb7s4\", function(module, exports) {\nmodule.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn)=>Promise.resolve().then(fn);\n\n});\n\nparcelRegister(\"8KR6e\", function(module, exports) {\n\nvar $fD4LP = parcelRequire(\"fD4LP\");\nmodule.exports = class FastFIFO {\n    constructor(hwm){\n        this.hwm = hwm || 16;\n        this.head = new $fD4LP(this.hwm);\n        this.tail = this.head;\n        this.length = 0;\n    }\n    clear() {\n        this.head = this.tail;\n        this.head.clear();\n        this.length = 0;\n    }\n    push(val) {\n        this.length++;\n        if (!this.head.push(val)) {\n            const prev = this.head;\n            this.head = prev.next = new $fD4LP(2 * this.head.buffer.length);\n            this.head.push(val);\n        }\n    }\n    shift() {\n        if (this.length !== 0) this.length--;\n        const val = this.tail.shift();\n        if (val === undefined && this.tail.next) {\n            const next = this.tail.next;\n            this.tail.next = null;\n            this.tail = next;\n            return this.tail.shift();\n        }\n        return val;\n    }\n    peek() {\n        const val = this.tail.peek();\n        if (val === undefined && this.tail.next) return this.tail.next.peek();\n        return val;\n    }\n    isEmpty() {\n        return this.length === 0;\n    }\n};\n\n});\nparcelRegister(\"fD4LP\", function(module, exports) {\nmodule.exports = class FixedFIFO {\n    constructor(hwm){\n        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two');\n        this.buffer = new Array(hwm);\n        this.mask = hwm - 1;\n        this.top = 0;\n        this.btm = 0;\n        this.next = null;\n    }\n    clear() {\n        this.top = this.btm = 0;\n        this.next = null;\n        this.buffer.fill(undefined);\n    }\n    push(data) {\n        if (this.buffer[this.top] !== undefined) return false;\n        this.buffer[this.top] = data;\n        this.top = this.top + 1 & this.mask;\n        return true;\n    }\n    shift() {\n        const last = this.buffer[this.btm];\n        if (last === undefined) return undefined;\n        this.buffer[this.btm] = undefined;\n        this.btm = this.btm + 1 & this.mask;\n        return last;\n    }\n    peek() {\n        return this.buffer[this.btm];\n    }\n    isEmpty() {\n        return this.buffer[this.btm] === undefined;\n    }\n};\n\n});\n\n\nparcelRegister(\"dwlN4\", function(module, exports) {\n\nvar $j8dkl = parcelRequire(\"j8dkl\");\n\nvar $j8dkl = parcelRequire(\"j8dkl\");\nmodule.exports = class TextDecoder {\n    constructor(encoding = 'utf8'){\n        this.encoding = $9d7f2aa139d703c2$var$normalizeEncoding(encoding);\n        switch(this.encoding){\n            case 'utf8':\n                this.decoder = new $j8dkl();\n                break;\n            case 'utf16le':\n            case 'base64':\n                throw new Error('Unsupported encoding: ' + this.encoding);\n            default:\n                this.decoder = new $j8dkl(this.encoding);\n        }\n    }\n    get remaining() {\n        return this.decoder.remaining;\n    }\n    push(data) {\n        if (typeof data === 'string') return data;\n        return this.decoder.decode(data);\n    }\n    // For Node.js compatibility\n    write(data) {\n        return this.push(data);\n    }\n    end(data) {\n        let result = '';\n        if (data) result = this.push(data);\n        result += this.decoder.flush();\n        return result;\n    }\n};\nfunction $9d7f2aa139d703c2$var$normalizeEncoding(encoding) {\n    encoding = encoding.toLowerCase();\n    switch(encoding){\n        case 'utf8':\n        case 'utf-8':\n            return 'utf8';\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return 'utf16le';\n        case 'latin1':\n        case 'binary':\n            return 'latin1';\n        case 'base64':\n        case 'ascii':\n        case 'hex':\n            return encoding;\n        default:\n            throw new Error('Unknown encoding: ' + encoding);\n    }\n}\n\n});\nparcelRegister(\"j8dkl\", function(module, exports) {\nmodule.exports = class BrowserDecoder {\n    constructor(encoding){\n        this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding);\n    }\n    get remaining() {\n        return -1;\n    }\n    decode(data) {\n        return this.decoder.decode(data, {\n            stream: true\n        });\n    }\n    flush() {\n        return this.decoder.decode(new Uint8Array(0));\n    }\n};\n\n});\n\n\n\nparcelRegister(\"6mAaY\", function(module, exports) {\n'use strict';\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */ /**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */ function $4a20dbf5fa201e08$var$assign(obj, props) {\n    for(const key in props)Object.defineProperty(obj, key, {\n        value: props[key],\n        enumerable: true,\n        configurable: true\n    });\n    return obj;\n}\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */ function $4a20dbf5fa201e08$var$createError(err, code, props) {\n    if (!err || typeof err === 'string') throw new TypeError('Please pass an Error to err-code');\n    if (!props) props = {};\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n    if (code) props.code = code;\n    try {\n        return $4a20dbf5fa201e08$var$assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n        const ErrClass = function() {};\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n        // @ts-ignore\n        const output = $4a20dbf5fa201e08$var$assign(new ErrClass(), props);\n        return output;\n    }\n}\nmodule.exports = $4a20dbf5fa201e08$var$createError;\n\n});\n\nparcelRegister(\"4aZbe\", function(module, exports) {\n\n$parcel$export(module.exports, \"text2arr\", function () { return $30a78db839b82430$export$5ef417313c99c2ea; });\n$parcel$export(module.exports, \"randomBytes\", function () { return $30a78db839b82430$export$5f828d93ff035aa8; });\n\nvar $3bdLe = parcelRequire(\"3bdLe\");\n\nvar $9t499 = parcelRequire(\"9t499\");\nconst $30a78db839b82430$var$decoder = new TextDecoder();\nconst $30a78db839b82430$export$7a7f11c15ae14c9b = (data, enc)=>{\n    if (!enc) return $30a78db839b82430$var$decoder.decode(data);\n    const dec = new TextDecoder(enc);\n    return dec.decode(data);\n};\n// sacrifice ~20% speed for bundle size\nconst $30a78db839b82430$var$encoder = new TextEncoder();\nconst $30a78db839b82430$export$5ef417313c99c2ea = (str)=>$30a78db839b82430$var$encoder.encode(str);\nconst $30a78db839b82430$export$7c3185bb3390e93 = (data)=>(0, $9t499.encode)(data);\nconst $30a78db839b82430$export$69f449cc2c99fa62 = (str)=>new Uint8Array((0, $9t499.decode)(str));\nconst $30a78db839b82430$export$49fe209f945af2c = (str)=>{\n    let res = '';\n    let c;\n    let i = 0;\n    const len = str.length;\n    while(i < len){\n        c = str.charCodeAt(i++);\n        res += (0, $3bdLe.alphabet)[c >> 4] + (0, $3bdLe.alphabet)[c & 0xF];\n    }\n    return res;\n};\nconst $30a78db839b82430$var$MAX_ARGUMENTS_LENGTH = 0x10000;\nconst $30a78db839b82430$export$dac5d37a50f22f11 = (hex)=>{\n    const points = (0, $3bdLe.hex2arr)(hex);\n    if (points.length <= $30a78db839b82430$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points);\n    let res = '';\n    let i = 0;\n    while(i < points.length)res += String.fromCharCode(...points.subarray(i, i += $30a78db839b82430$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n};\nconst $30a78db839b82430$var$scope = typeof window !== 'undefined' ? window : self;\nconst $30a78db839b82430$var$crypto = $30a78db839b82430$var$scope.crypto || $30a78db839b82430$var$scope.msCrypto || {};\nconst $30a78db839b82430$var$subtle = $30a78db839b82430$var$crypto.subtle || $30a78db839b82430$var$crypto.webkitSubtle;\nconst $30a78db839b82430$var$formatMap = {\n    hex: (0, $3bdLe.arr2hex),\n    base64: $30a78db839b82430$export$7c3185bb3390e93\n};\nconst $30a78db839b82430$export$d6af199866bfb566 = async (data, format, algo = 'sha-1')=>{\n    if (!$30a78db839b82430$var$subtle) throw new Error('no web crypto support');\n    if (typeof data === 'string') data = $30a78db839b82430$export$5ef417313c99c2ea(data);\n    const out = new Uint8Array(await $30a78db839b82430$var$subtle.digest(algo, data));\n    return format ? $30a78db839b82430$var$formatMap[format](out) : out;\n};\nconst $30a78db839b82430$export$5f828d93ff035aa8 = (size)=>{\n    const view = new Uint8Array(size);\n    return $30a78db839b82430$var$crypto.getRandomValues(view);\n};\n\n});\nparcelRegister(\"3bdLe\", function(module, exports) {\n\n$parcel$export(module.exports, \"alphabet\", function () { return $250d12c4048d99a7$export$1b9ece1fd5efdcd7; });\n$parcel$export(module.exports, \"arr2hex\", function () { return $250d12c4048d99a7$export$70d45ef99b984e19; });\n$parcel$export(module.exports, \"hex2arr\", function () { return $250d12c4048d99a7$export$30a0448ba3664bd6; });\n/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/ const $250d12c4048d99a7$export$1b9ece1fd5efdcd7 = '0123456789abcdef';\nconst $250d12c4048d99a7$var$encodeLookup = [];\nconst $250d12c4048d99a7$var$decodeLookup = [];\nfor(let i = 0; i < 256; i++){\n    $250d12c4048d99a7$var$encodeLookup[i] = $250d12c4048d99a7$export$1b9ece1fd5efdcd7[i >> 4 & 0xf] + $250d12c4048d99a7$export$1b9ece1fd5efdcd7[i & 0xf];\n    if (i < 16) {\n        if (i < 10) $250d12c4048d99a7$var$decodeLookup[0x30 + i] = i;\n        else $250d12c4048d99a7$var$decodeLookup[87 + i] = i;\n    }\n}\nconst $250d12c4048d99a7$export$70d45ef99b984e19 = (data)=>{\n    const length = data.length;\n    let string = '';\n    let i = 0;\n    while(i < length)string += $250d12c4048d99a7$var$encodeLookup[data[i++]];\n    return string;\n};\nconst $250d12c4048d99a7$export$30a0448ba3664bd6 = (str)=>{\n    const sizeof = str.length >> 1;\n    const length = sizeof << 1;\n    const array = new Uint8Array(sizeof);\n    let n = 0;\n    let i = 0;\n    while(i < length)array[n++] = $250d12c4048d99a7$var$decodeLookup[str.charCodeAt(i++)] << 4 | $250d12c4048d99a7$var$decodeLookup[str.charCodeAt(i++)];\n    return array;\n};\nconst $250d12c4048d99a7$export$ee1b3e54f0441b22 = (chunks, size = 0)=>{\n    const length = chunks.length || 0;\n    if (!size) {\n        let i = length;\n        while(i--)size += chunks[i].length;\n    }\n    const b = new Uint8Array(size);\n    let offset = size;\n    let i = length;\n    while(i--){\n        offset -= chunks[i].length;\n        b.set(chunks[i], offset);\n    }\n    return b;\n};\nconst $250d12c4048d99a7$export$411ce8e5a71e3069 = (a, b)=>{\n    if (a.length !== b.length) return false;\n    for(let i = a.length; i > -1; i -= 1){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\n\n});\n\nparcelRegister(\"9t499\", function(module, exports) {\n\n$parcel$export(module.exports, \"encode\", function () { return $6e4a09eefdefdb9a$export$c564cdbbe6da493; });\n$parcel$export(module.exports, \"decode\", function () { return $6e4a09eefdefdb9a$export$2f872c0f2117be69; });\n/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */ var $6e4a09eefdefdb9a$var$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar $6e4a09eefdefdb9a$var$lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor(var $6e4a09eefdefdb9a$var$i = 0; $6e4a09eefdefdb9a$var$i < $6e4a09eefdefdb9a$var$chars.length; $6e4a09eefdefdb9a$var$i++)$6e4a09eefdefdb9a$var$lookup[$6e4a09eefdefdb9a$var$chars.charCodeAt($6e4a09eefdefdb9a$var$i)] = $6e4a09eefdefdb9a$var$i;\nvar $6e4a09eefdefdb9a$export$c564cdbbe6da493 = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for(i = 0; i < len; i += 3){\n        base64 += $6e4a09eefdefdb9a$var$chars[bytes[i] >> 2];\n        base64 += $6e4a09eefdefdb9a$var$chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64 += $6e4a09eefdefdb9a$var$chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64 += $6e4a09eefdefdb9a$var$chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) base64 = base64.substring(0, base64.length - 1) + '=';\n    else if (len % 3 === 1) base64 = base64.substring(0, base64.length - 2) + '==';\n    return base64;\n};\nvar $6e4a09eefdefdb9a$export$2f872c0f2117be69 = function(base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') bufferLength--;\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for(i = 0; i < len; i += 4){\n        encoded1 = $6e4a09eefdefdb9a$var$lookup[base64.charCodeAt(i)];\n        encoded2 = $6e4a09eefdefdb9a$var$lookup[base64.charCodeAt(i + 1)];\n        encoded3 = $6e4a09eefdefdb9a$var$lookup[base64.charCodeAt(i + 2)];\n        encoded4 = $6e4a09eefdefdb9a$var$lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return arraybuffer;\n};\n\n});\n\n\n\n\n\nparcelRegister(\"dZ1ej\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", function () { return $a2e1ed1997be3b3c$export$2e2bcd8739ae039; });\n\nvar $cQlYm = parcelRequire(\"cQlYm\");\nconst $a2e1ed1997be3b3c$var$TypedArray = Object.getPrototypeOf(Uint8Array);\nconst $a2e1ed1997be3b3c$var$typeByteLimit = 12;\nconst $a2e1ed1997be3b3c$var$typeIndex = 0;\nconst $a2e1ed1997be3b3c$var$nonceIndex = $a2e1ed1997be3b3c$var$typeIndex + $a2e1ed1997be3b3c$var$typeByteLimit;\nconst $a2e1ed1997be3b3c$var$tagIndex = $a2e1ed1997be3b3c$var$nonceIndex + 1;\nconst $a2e1ed1997be3b3c$var$progressIndex = $a2e1ed1997be3b3c$var$tagIndex + 1;\nconst $a2e1ed1997be3b3c$var$payloadIndex = $a2e1ed1997be3b3c$var$progressIndex + 1;\nconst $a2e1ed1997be3b3c$var$chunkSize = 16384 - $a2e1ed1997be3b3c$var$payloadIndex;\nconst $a2e1ed1997be3b3c$var$oneByteMax = 0xff;\nconst $a2e1ed1997be3b3c$var$buffLowEvent = 'bufferedamountlow';\nconst $a2e1ed1997be3b3c$var$internalNs = (ns)=>'@_' + ns;\nvar $a2e1ed1997be3b3c$export$2e2bcd8739ae039 = (onPeer, onPeerLeave, onSelfLeave)=>{\n    const peerMap = {};\n    const actions = {};\n    const actionsCache = {};\n    const pendingTransmissions = {};\n    const pendingPongs = {};\n    const pendingStreamMetas = {};\n    const pendingTrackMetas = {};\n    const listeners = {\n        onPeerJoin: (0, $cQlYm.noOp),\n        onPeerLeave: (0, $cQlYm.noOp),\n        onPeerStream: (0, $cQlYm.noOp),\n        onPeerTrack: (0, $cQlYm.noOp)\n    };\n    const iterate = (targets, f)=>(targets ? Array.isArray(targets) ? targets : [\n            targets\n        ] : (0, $cQlYm.keys)(peerMap)).flatMap((id)=>{\n            const peer = peerMap[id];\n            if (!peer) {\n                console.warn(`${(0, $cQlYm.libName)}: no peer with id ${id} found`);\n                return [];\n            }\n            return f(id, peer);\n        });\n    const exitPeer = (id)=>{\n        if (!peerMap[id]) return;\n        delete peerMap[id];\n        delete pendingTransmissions[id];\n        delete pendingPongs[id];\n        listeners.onPeerLeave(id);\n        onPeerLeave(id);\n    };\n    const makeAction = (type)=>{\n        if (actions[type]) return actionsCache[type];\n        if (!type) throw (0, $cQlYm.mkErr)('action type argument is required');\n        const typeBytes = (0, $cQlYm.encodeBytes)(type);\n        if (typeBytes.byteLength > $a2e1ed1997be3b3c$var$typeByteLimit) throw (0, $cQlYm.mkErr)(`action type string \"${type}\" (${typeBytes.byteLength}b) exceeds ` + `byte limit (${$a2e1ed1997be3b3c$var$typeByteLimit}). Hint: choose a shorter name.`);\n        const typeBytesPadded = new Uint8Array($a2e1ed1997be3b3c$var$typeByteLimit);\n        typeBytesPadded.set(typeBytes);\n        let nonce = 0;\n        actions[type] = {\n            onComplete: (0, $cQlYm.noOp),\n            onProgress: (0, $cQlYm.noOp),\n            setOnComplete: (f)=>actions[type] = {\n                    ...actions[type],\n                    onComplete: f\n                },\n            setOnProgress: (f)=>actions[type] = {\n                    ...actions[type],\n                    onProgress: f\n                },\n            send: async (data, targets, meta, onProgress)=>{\n                if (meta && typeof meta !== 'object') throw (0, $cQlYm.mkErr)('action meta argument must be an object');\n                const dataType = typeof data;\n                if (dataType === 'undefined') throw (0, $cQlYm.mkErr)('action data cannot be undefined');\n                const isJson = dataType !== 'string';\n                const isBlob = data instanceof Blob;\n                const isBinary = isBlob || data instanceof ArrayBuffer || data instanceof $a2e1ed1997be3b3c$var$TypedArray;\n                if (meta && !isBinary) throw (0, $cQlYm.mkErr)('action meta argument can only be used with binary data');\n                const buffer = isBinary ? new Uint8Array(isBlob ? await data.arrayBuffer() : data) : (0, $cQlYm.encodeBytes)(isJson ? (0, $cQlYm.toJson)(data) : data);\n                const metaEncoded = meta ? (0, $cQlYm.encodeBytes)((0, $cQlYm.toJson)(meta)) : null;\n                const chunkTotal = Math.ceil(buffer.byteLength / $a2e1ed1997be3b3c$var$chunkSize) + (meta ? 1 : 0) || 1;\n                const chunks = (0, $cQlYm.alloc)(chunkTotal, (_, i)=>{\n                    const isLast = i === chunkTotal - 1;\n                    const isMeta = meta && i === 0;\n                    const chunk = new Uint8Array($a2e1ed1997be3b3c$var$payloadIndex + (isMeta ? metaEncoded.byteLength : isLast ? buffer.byteLength - $a2e1ed1997be3b3c$var$chunkSize * (chunkTotal - (meta ? 2 : 1)) : $a2e1ed1997be3b3c$var$chunkSize));\n                    chunk.set(typeBytesPadded);\n                    chunk.set([\n                        nonce\n                    ], $a2e1ed1997be3b3c$var$nonceIndex);\n                    chunk.set([\n                        isLast | isMeta << 1 | isBinary << 2 | isJson << 3\n                    ], $a2e1ed1997be3b3c$var$tagIndex);\n                    chunk.set([\n                        Math.round((i + 1) / chunkTotal * $a2e1ed1997be3b3c$var$oneByteMax)\n                    ], $a2e1ed1997be3b3c$var$progressIndex);\n                    chunk.set(meta ? isMeta ? metaEncoded : buffer.subarray((i - 1) * $a2e1ed1997be3b3c$var$chunkSize, i * $a2e1ed1997be3b3c$var$chunkSize) : buffer.subarray(i * $a2e1ed1997be3b3c$var$chunkSize, (i + 1) * $a2e1ed1997be3b3c$var$chunkSize), $a2e1ed1997be3b3c$var$payloadIndex);\n                    return chunk;\n                });\n                nonce = nonce + 1 & $a2e1ed1997be3b3c$var$oneByteMax;\n                return (0, $cQlYm.all)(iterate(targets, async (id, peer)=>{\n                    const { channel: channel } = peer;\n                    let chunkN = 0;\n                    while(chunkN < chunkTotal){\n                        const chunk = chunks[chunkN];\n                        if (channel.bufferedAmount > channel.bufferedAmountLowThreshold) await new Promise((res)=>{\n                            const next = ()=>{\n                                channel.removeEventListener($a2e1ed1997be3b3c$var$buffLowEvent, next);\n                                res();\n                            };\n                            channel.addEventListener($a2e1ed1997be3b3c$var$buffLowEvent, next);\n                        });\n                        if (!peerMap[id]) break;\n                        peer.sendData(chunk);\n                        chunkN++;\n                        onProgress?.(chunk[$a2e1ed1997be3b3c$var$progressIndex] / $a2e1ed1997be3b3c$var$oneByteMax, id, meta);\n                    }\n                }));\n            }\n        };\n        return actionsCache[type] ||= [\n            actions[type].send,\n            actions[type].setOnComplete,\n            actions[type].setOnProgress\n        ];\n    };\n    const handleData = (id, data)=>{\n        const buffer = new Uint8Array(data);\n        const type = (0, $cQlYm.decodeBytes)(buffer.subarray($a2e1ed1997be3b3c$var$typeIndex, $a2e1ed1997be3b3c$var$nonceIndex)).replaceAll('\\x00', '');\n        const [nonce] = buffer.subarray($a2e1ed1997be3b3c$var$nonceIndex, $a2e1ed1997be3b3c$var$tagIndex);\n        const [tag] = buffer.subarray($a2e1ed1997be3b3c$var$tagIndex, $a2e1ed1997be3b3c$var$progressIndex);\n        const [progress] = buffer.subarray($a2e1ed1997be3b3c$var$progressIndex, $a2e1ed1997be3b3c$var$payloadIndex);\n        const payload = buffer.subarray($a2e1ed1997be3b3c$var$payloadIndex);\n        const isLast = !!(tag & 1);\n        const isMeta = !!(tag & 2);\n        const isBinary = !!(tag & 4);\n        const isJson = !!(tag & 8);\n        if (!actions[type]) {\n            console.warn(`${(0, $cQlYm.libName)}: received message with unregistered type (${type})`);\n            return;\n        }\n        pendingTransmissions[id] ||= {};\n        pendingTransmissions[id][type] ||= {};\n        const target = pendingTransmissions[id][type][nonce] ||= {\n            chunks: []\n        };\n        if (isMeta) target.meta = (0, $cQlYm.fromJson)((0, $cQlYm.decodeBytes)(payload));\n        else target.chunks.push(payload);\n        actions[type].onProgress(progress / $a2e1ed1997be3b3c$var$oneByteMax, id, target.meta);\n        if (!isLast) return;\n        const full = new Uint8Array(target.chunks.reduce((a, c)=>a + c.byteLength, 0));\n        target.chunks.reduce((a, c)=>{\n            full.set(c, a);\n            return a + c.byteLength;\n        }, 0);\n        delete pendingTransmissions[id][type][nonce];\n        if (isBinary) actions[type].onComplete(full, id, target.meta);\n        else {\n            const text = (0, $cQlYm.decodeBytes)(full);\n            actions[type].onComplete(isJson ? (0, $cQlYm.fromJson)(text) : text, id);\n        }\n    };\n    const leave = async ()=>{\n        await sendLeave('');\n        await new Promise((res)=>setTimeout(res, 99));\n        (0, $cQlYm.entries)(peerMap).forEach(([id, peer])=>{\n            peer.destroy();\n            delete peerMap[id];\n        });\n        onSelfLeave();\n    };\n    const [sendPing, getPing] = makeAction($a2e1ed1997be3b3c$var$internalNs('ping'));\n    const [sendPong, getPong] = makeAction($a2e1ed1997be3b3c$var$internalNs('pong'));\n    const [sendSignal, getSignal] = makeAction($a2e1ed1997be3b3c$var$internalNs('signal'));\n    const [sendStreamMeta, getStreamMeta] = makeAction($a2e1ed1997be3b3c$var$internalNs('stream'));\n    const [sendTrackMeta, getTrackMeta] = makeAction($a2e1ed1997be3b3c$var$internalNs('track'));\n    const [sendLeave, getLeave] = makeAction($a2e1ed1997be3b3c$var$internalNs('leave'));\n    onPeer((peer, id)=>{\n        if (peerMap[id]) return;\n        peerMap[id] = peer;\n        peer.setHandlers({\n            data: (d)=>handleData(id, d),\n            stream: (stream)=>{\n                listeners.onPeerStream(stream, id, pendingStreamMetas[id]);\n                delete pendingStreamMetas[id];\n            },\n            track: (track, stream)=>{\n                listeners.onPeerTrack(track, stream, id, pendingTrackMetas[id]);\n                delete pendingTrackMetas[id];\n            },\n            signal: (sdp)=>sendSignal(sdp, id),\n            close: ()=>exitPeer(id),\n            error: ()=>exitPeer(id)\n        });\n        listeners.onPeerJoin(id);\n        peer.drainEarlyData?.((d)=>handleData(id, d));\n    });\n    getPing((_, id)=>sendPong('', id));\n    getPong((_, id)=>{\n        pendingPongs[id]?.();\n        delete pendingPongs[id];\n    });\n    getSignal((sdp, id)=>peerMap[id]?.signal(sdp));\n    getStreamMeta((meta, id)=>pendingStreamMetas[id] = meta);\n    getTrackMeta((meta, id)=>pendingTrackMetas[id] = meta);\n    getLeave((_, id)=>exitPeer(id));\n    if (0, $cQlYm.isBrowser) addEventListener('beforeunload', leave);\n    return {\n        makeAction: makeAction,\n        leave: leave,\n        ping: async (id)=>{\n            if (!id) throw (0, $cQlYm.mkErr)('ping() must be called with target peer ID');\n            const start = Date.now();\n            sendPing('', id);\n            await new Promise((res)=>pendingPongs[id] = res);\n            return Date.now() - start;\n        },\n        getPeers: ()=>(0, $cQlYm.fromEntries)((0, $cQlYm.entries)(peerMap).map(([id, peer])=>[\n                    id,\n                    peer.connection\n                ])),\n        addStream: (stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendStreamMeta(meta, id);\n                peer.addStream(stream);\n            }),\n        removeStream: (stream, targets)=>iterate(targets, (_, peer)=>peer.removeStream(stream)),\n        addTrack: (track, stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendTrackMeta(meta, id);\n                peer.addTrack(track, stream);\n            }),\n        removeTrack: (track, stream, targets)=>iterate(targets, (_, peer)=>peer.removeTrack(track, stream)),\n        replaceTrack: (oldTrack, newTrack, stream, targets, meta)=>iterate(targets, async (id, peer)=>{\n                if (meta) await sendTrackMeta(meta, id);\n                peer.replaceTrack(oldTrack, newTrack, stream);\n            }),\n        onPeerJoin: (f)=>listeners.onPeerJoin = f,\n        onPeerLeave: (f)=>listeners.onPeerLeave = f,\n        onPeerStream: (f)=>listeners.onPeerStream = f,\n        onPeerTrack: (f)=>listeners.onPeerTrack = f\n    };\n};\n\n});\n\n\n\n\n})();\n//# sourceMappingURL=trystero.4f19cd1f.js.map\n","export {getRelaySockets, joinRoom, selfId} from './nostr.js'\n","import {schnorr} from '@noble/curves/secp256k1'\nimport strategy from './strategy.js'\nimport {\n  encodeBytes,\n  fromJson,\n  genId,\n  getRelays,\n  isBrowser,\n  libName,\n  makeSocket,\n  selfId,\n  socketGetter,\n  toHex,\n  toJson\n} from './utils.js'\n\nconst clients = {}\nconst defaultRedundancy = 5\nconst kind = 29333\nconst tag = 'x'\nconst eventMsgType = 'EVENT'\nconst privateKey = isBrowser && schnorr.utils.randomPrivateKey()\nconst publicKey = isBrowser && toHex(schnorr.getPublicKey(privateKey))\nconst subIdToTopic = {}\nconst msgHandlers = {}\n\nconst now = () => Math.floor(Date.now() / 1000)\n\nconst createEvent = async (topic, content) => {\n  const payload = {\n    kind,\n    content,\n    pubkey: publicKey,\n    created_at: now(),\n    tags: [[tag, topic]]\n  }\n\n  const id = toHex(\n    new Uint8Array(\n      await crypto.subtle.digest(\n        'SHA-256',\n        encodeBytes(\n          toJson([\n            0,\n            payload.pubkey,\n            payload.created_at,\n            payload.kind,\n            payload.tags,\n            payload.content\n          ])\n        )\n      )\n    )\n  )\n\n  return toJson([\n    eventMsgType,\n    {\n      ...payload,\n      id,\n      sig: toHex(await schnorr.sign(id, privateKey))\n    }\n  ])\n}\n\nconst subscribe = (subId, topic) => {\n  subIdToTopic[subId] = topic\n  return toJson([\n    'REQ',\n    subId,\n    {\n      kinds: [kind],\n      since: now(),\n      ['#' + tag]: [topic]\n    }\n  ])\n}\n\nconst unsubscribe = subId => {\n  delete subIdToTopic[subId]\n  return toJson(['CLOSE', subId])\n}\n\nexport const joinRoom = strategy({\n  init: config =>\n    getRelays(config, defaultRelayUrls, defaultRedundancy).map(url => {\n      const client = makeSocket(url, data => {\n        const [msgType, subId, payload, relayMsg] = fromJson(data)\n\n        if (msgType !== eventMsgType) {\n          const prefix = `${libName}: relay failure from ${client.url} - `\n\n          if (msgType === 'NOTICE') {\n            console.warn(prefix + subId)\n          } else if (msgType === 'OK' && !payload) {\n            console.warn(prefix + relayMsg)\n          }\n          return\n        }\n\n        msgHandlers[subId]?.(subIdToTopic[subId], payload.content)\n      })\n\n      clients[url] = client\n\n      return client.ready\n    }),\n\n  subscribe: (client, rootTopic, selfTopic, onMessage) => {\n    const rootSubId = genId(64)\n    const selfSubId = genId(64)\n\n    msgHandlers[rootSubId] = msgHandlers[selfSubId] = (topic, data) =>\n      onMessage(topic, data, async (peerTopic, signal) =>\n        client.send(await createEvent(peerTopic, signal))\n      )\n\n    client.send(subscribe(rootSubId, rootTopic))\n    client.send(subscribe(selfSubId, selfTopic))\n\n    return () => {\n      client.send(unsubscribe(rootSubId))\n      client.send(unsubscribe(selfSubId))\n      delete msgHandlers[rootSubId]\n      delete msgHandlers[selfSubId]\n    }\n  },\n\n  announce: async (client, rootTopic) =>\n    client.send(await createEvent(rootTopic, toJson({peerId: selfId})))\n})\n\nexport const getRelaySockets = socketGetter(clients)\n\nexport {selfId} from './utils.js'\n\nexport const defaultRelayUrls = [\n  'relay.nostr.net',\n  'relay.snort.social',\n  'relay.piazza.today',\n  'relay.exit.pub',\n  'nostr.lu.ke',\n  'nostr.mom',\n  'relay.urbanzap.space',\n  'nostr.data.haus',\n  'nostr.sathoarder.com',\n  'relay.nostromo.social',\n  'relay.nostr.bg',\n  'nostr.stakey.net',\n  'nostr.vulpem.com',\n  'a.nos.lol',\n  'eu.purplerelay.com',\n  'nostr2.sanhauf.com',\n  'e.nos.lol'\n].map(url => 'wss://' + url)\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst _shortw_utils_js_1 = require(\"./_shortw_utils.js\");\nconst hash_to_curve_js_1 = require(\"./abstract/hash-to-curve.js\");\nconst modular_js_1 = require(\"./abstract/modular.js\");\nconst utils_js_1 = require(\"./abstract/utils.js\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n */\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0, utils_js_1.aInRange)('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = utils_js_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n */\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\nexports.hashToCurve = (() => htf.hashToCurve)();\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve } from './_shortw_utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport {\n  inRange,\n  aInRange,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  numberToBytesBE,\n} from './abstract/utils.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n */\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  aInRange('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n    if (!inRange(r, _1n, secp256k1P)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n    if (!inRange(s, _1n, secp256k1N)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Schnorr signatures over secp256k1.\n */\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = exports.SHA256 = void 0;\nconst _md_js_1 = require(\"./_md.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js_1.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nexports.SHA256 = SHA256;\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HashMD = exports.Maj = exports.Chi = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\nexports.Chi = Chi;\n/**\n * Majority function, true if any two inputs is true\n */\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\nexports.Maj = Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.aexists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.HashMD = HashMD;\n//# sourceMappingURL=_md.js.map","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.anumber = anumber;\nexports.number = anumber;\nexports.abytes = abytes;\nexports.bytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput,\n};\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","function anumber(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };\n\nconst assert = {\n  number: anumber,\n  bytes: abytes,\n  hash: ahash,\n  exists: aexists,\n  output: aoutput,\n};\nexport default assert;\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\nexports.isBytes = isBytes;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.toBytes = toBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.wrapConstructor = wrapConstructor;\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexports.rotl = rotl;\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return crypto_1.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\nexport const isLE = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) => n : (n: number) => byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { CHash } from './abstract/utils.js';\nimport { CurveType, weierstrass } from './abstract/weierstrass.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.ahash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.aexists)(this);\n        (0, _assert_js_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { ahash, abytes, aexists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DER = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nconst curve_js_1 = require(\"./curve.js\");\nconst mod = require(\"./modular.js\");\nconst ut = require(\"./utils.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0, utils_js_1.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0, utils_js_1.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = ut.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = ut.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = ut.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        ut.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = mod.Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return ut.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (ut.isBytes(key))\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, N); // disabled by default, enabled for BLS\n        ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_js_1.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_js_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            ut.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            (0, utils_js_1.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!ut.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = ut.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || ut.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport {\n  AffinePoint,\n  BasicCurve,\n  Group,\n  GroupConstructor,\n  validateBasic,\n  wNAF,\n  pippenger,\n} from './curve.js';\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes, memoized, abool } from './utils.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | boolean;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean; format?: 'compact' | 'der' | undefined };\n\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\n\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = ut.numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = ut.numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint) {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = ut.numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return b2n(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    ut.abytes(data);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n  const Fn = mod.Field(CURVE.n, CURVE.nBitLength);\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return ut.inRange(num, _1n, CURVE.n);\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length))\n        throw new Error('invalid private key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(\n        'invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key\n      );\n    }\n    if (wrapPrivateKey) num = mod.mod(num, N); // disabled by default, enabled for BLS\n    ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n    return num;\n  }\n\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (x, y, z) ∋ (x=x/z, y=y/z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { px: x, py: y, pz: z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    // Check if x, y are valid field elements\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(\n      readonly px: T,\n      readonly py: T,\n      readonly pz: T\n    ) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n      Object.freeze(this);\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo, n: N } = CURVE;\n      ut.aInRange('scalar', sc, _0n, N);\n      const I = Point.ZERO;\n      if (sc === _0n) return I;\n      if (this.is0() || sc === _1n) return this;\n\n      // Case a: no endomorphism. Case b: has precomputes.\n      if (!endo || wnaf.hasPrecomputes(this))\n        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n\n      // Case c: endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo, n: N } = CURVE;\n      ut.aInRange('scalar', scalar, _1n, N);\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      return toAffineMemo(this, iz);\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      abool('isCompressed', isCompressed);\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      abool('isCompressed', isCompressed);\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!ut.inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y: bigint;\n        try {\n          y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        } catch (sqrtError) {\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n          throw new Error('Point is not on curve' + suffix);\n        }\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        const cl = compressedLen;\n        const ul = uncompressedLen;\n        throw new Error(\n          'invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(\n      readonly r: bigint,\n      readonly s: bigint,\n      readonly recovery?: number\n    ) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n      ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = ut.isBytes(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\"\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    const { lowS, prehash, format } = opts;\n\n    // Verify opts, deduce signature format\n    validateSigVerOpts(opts);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    if (format !== undefined && format !== 'compact' && format !== 'der')\n      throw new Error('format must be compact or der');\n    const isHex = typeof sg === 'string' || ut.isBytes(sg);\n    const isObj =\n      !isHex &&\n      !format &&\n      typeof sg === 'object' &&\n      sg !== null &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (isObj) _sig = new Signature(sg.r, sg.s);\n      if (isHex) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = (0, utils_js_1.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject, bitLen } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\nfunction calcWOpts(W: number, bits: number) {\n  validateW(W, bits);\n  const windows = Math.ceil(bits / W) + 1; // +1, because\n  const windowSize = 2 ** (W - 1); // -1 because we skip zero\n  return { windows, windowSize };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>(); // This allows use make points immutable (nothing changes inside)\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = calcWOpts(W, bits);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        if (n === _0n) break; // No need to go over empty scalar\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) continue;\n        let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n        if (wbits < 0) curr = curr.negate();\n        // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n        acc = acc.add(curr);\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length)\n    throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n) {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar × 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 × 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = BigInt((1 << windowSize) - 1);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nconst utils_js_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nfunction FpLegendre(order) {\n    // (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n    // (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n =/* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\nexport function FpLegendre(order: bigint) {\n  // (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n  // (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return <T>(f: IField<T>, x: T): T => f.pow(x, legendreConst);\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendre = FpLegendre(f.ORDER);\n  return (x: T): boolean => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.bytesToHex = bytesToHex;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean) {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(fn: (arg: T, ...args: O) => R) {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_js_1.abytes)(msg);\n    (0, utils_js_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_js_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { AffinePoint, Group, GroupConstructor } from './curve.js';\nimport { IField, mod } from './modular.js';\nimport type { CHash } from './utils.js';\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  abytes(msg);\n  anum(count);\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]) {\n  // Make same order as in spec\n  const COEFF = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\n\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  def: Opts & { encodeDST?: UnicodeOrBytes }\n) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n    // Same as encodeToCurve, but without hash\n    mapToCurve(scalars: bigint[]) {\n      if (!Array.isArray(scalars)) throw new Error('mapToCurve: expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('mapToCurve: expected array of bigints');\n      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n  };\n}\n","import {decrypt, encrypt, genKey, sha1} from './crypto.js'\nimport initPeer from './peer.js'\nimport room from './room.js'\nimport {\n  all,\n  alloc,\n  fromJson,\n  libName,\n  mkErr,\n  noOp,\n  selfId,\n  toJson,\n  topicPath\n} from './utils.js'\n\nconst poolSize = 20\nconst announceIntervalMs = 5_333\nconst offerTtl = 57_333\n\nexport default ({init, subscribe, announce}) => {\n  const occupiedRooms = {}\n\n  let didInit = false\n  let initPromises\n  let offerPool\n  let offerCleanupTimer\n\n  return (config, roomId, onJoinError) => {\n    const {appId} = config\n\n    if (occupiedRooms[appId]?.[roomId]) {\n      return occupiedRooms[appId][roomId]\n    }\n\n    const pendingOffers = {}\n    const connectedPeers = {}\n    const rootTopicPlaintext = topicPath(libName, appId, roomId)\n    const rootTopicP = sha1(rootTopicPlaintext)\n    const selfTopicP = sha1(topicPath(rootTopicPlaintext, selfId))\n    const key = genKey(config.password || '', appId, roomId)\n\n    const withKey = f => async signal => ({\n      type: signal.type,\n      sdp: await f(key, signal.sdp)\n    })\n\n    const toPlain = withKey(decrypt)\n    const toCipher = withKey(encrypt)\n\n    const makeOffer = () => initPeer(true, config.rtcConfig)\n\n    const connectPeer = (peer, peerId, clientId) => {\n      if (connectedPeers[peerId]) {\n        if (connectedPeers[peerId] !== peer) {\n          peer.destroy()\n        }\n        return\n      }\n\n      connectedPeers[peerId] = peer\n      onPeerConnect(peer, peerId)\n\n      pendingOffers[peerId]?.forEach((peer, i) => {\n        if (i !== clientId) {\n          peer.destroy()\n        }\n      })\n      delete pendingOffers[peerId]\n    }\n\n    const disconnectPeer = (peer, peerId) => {\n      if (connectedPeers[peerId] === peer) {\n        delete connectedPeers[peerId]\n      }\n    }\n\n    const prunePendingOffer = (peerId, clientId) => {\n      if (connectedPeers[peerId]) {\n        return\n      }\n\n      const offer = pendingOffers[peerId]?.[clientId]\n\n      if (offer) {\n        delete pendingOffers[peerId][clientId]\n        offer.destroy()\n      }\n    }\n\n    const getOffers = n => {\n      offerPool.push(...alloc(n, makeOffer))\n\n      return all(\n        offerPool\n          .splice(0, n)\n          .map(peer =>\n            peer.offerPromise.then(toCipher).then(offer => ({peer, offer}))\n          )\n      )\n    }\n\n    const handleJoinError = (peerId, sdpType) =>\n      onJoinError?.({\n        error: `incorrect password (${config.password}) when decrypting ${sdpType}`,\n        appId,\n        peerId,\n        roomId\n      })\n\n    const handleMessage = clientId => async (topic, msg, signalPeer) => {\n      const [rootTopic, selfTopic] = await all([rootTopicP, selfTopicP])\n\n      if (topic !== rootTopic && topic !== selfTopic) {\n        return\n      }\n\n      const {peerId, offer, answer, peer} =\n        typeof msg === 'string' ? fromJson(msg) : msg\n\n      if (peerId === selfId || connectedPeers[peerId]) {\n        return\n      }\n\n      if (peerId && !offer && !answer) {\n        if (pendingOffers[peerId]?.[clientId]) {\n          return\n        }\n\n        const [[{peer, offer}], topic] = await all([\n          getOffers(1),\n          sha1(topicPath(rootTopicPlaintext, peerId))\n        ])\n\n        pendingOffers[peerId] ||= []\n        pendingOffers[peerId][clientId] = peer\n\n        setTimeout(\n          () => prunePendingOffer(peerId, clientId),\n          announceIntervals[clientId] * 0.9\n        )\n\n        peer.setHandlers({\n          connect: () => connectPeer(peer, peerId, clientId),\n          close: () => disconnectPeer(peer, peerId)\n        })\n\n        signalPeer(topic, toJson({peerId: selfId, offer}))\n      } else if (offer) {\n        const myOffer = pendingOffers[peerId]?.[clientId]\n\n        if (myOffer && selfId > peerId) {\n          return\n        }\n\n        const peer = initPeer(false, config.rtcConfig)\n        peer.setHandlers({\n          connect: () => connectPeer(peer, peerId, clientId),\n          close: () => disconnectPeer(peer, peerId)\n        })\n\n        let plainOffer\n\n        try {\n          plainOffer = await toPlain(offer)\n        } catch (_) {\n          handleJoinError(peerId, 'offer')\n          return\n        }\n\n        if (peer.isDead) {\n          return\n        }\n\n        const [topic, answer] = await all([\n          sha1(topicPath(rootTopicPlaintext, peerId)),\n          peer.signal(plainOffer)\n        ])\n\n        signalPeer(\n          topic,\n          toJson({peerId: selfId, answer: await toCipher(answer)})\n        )\n      } else if (answer) {\n        let plainAnswer\n\n        try {\n          plainAnswer = await toPlain(answer)\n        } catch (e) {\n          handleJoinError(peerId, 'answer')\n          return\n        }\n\n        if (peer) {\n          peer.setHandlers({\n            connect: () => connectPeer(peer, peerId, clientId),\n            close: () => disconnectPeer(peer, peerId)\n          })\n\n          peer.signal(plainAnswer)\n        } else {\n          const peer = pendingOffers[peerId]?.[clientId]\n\n          if (peer && !peer.isDead) {\n            peer.signal(plainAnswer)\n          }\n        }\n      }\n    }\n\n    if (!config) {\n      throw mkErr('requires a config map as the first argument')\n    }\n\n    if (!appId && !config.firebaseApp) {\n      throw mkErr('config map is missing appId field')\n    }\n\n    if (!roomId) {\n      throw mkErr('roomId argument required')\n    }\n\n    if (!didInit) {\n      const initRes = init(config)\n      offerPool = alloc(poolSize, makeOffer)\n      initPromises = Array.isArray(initRes) ? initRes : [initRes]\n      didInit = true\n      offerCleanupTimer = setInterval(\n        () =>\n          (offerPool = offerPool.filter(peer => {\n            const shouldLive = Date.now() - peer.created < offerTtl\n\n            if (!shouldLive) {\n              peer.destroy()\n            }\n\n            return shouldLive\n          })),\n        offerTtl * 1.03\n      )\n    }\n\n    const announceIntervals = initPromises.map(() => announceIntervalMs)\n    const announceTimeouts = []\n\n    const unsubFns = initPromises.map(async (clientP, i) =>\n      subscribe(\n        await clientP,\n        await rootTopicP,\n        await selfTopicP,\n        handleMessage(i),\n        getOffers\n      )\n    )\n\n    all([rootTopicP, selfTopicP]).then(([rootTopic, selfTopic]) => {\n      const queueAnnounce = async (client, i) => {\n        const ms = await announce(client, rootTopic, selfTopic)\n\n        if (typeof ms === 'number') {\n          announceIntervals[i] = ms\n        }\n\n        announceTimeouts[i] = setTimeout(\n          () => queueAnnounce(client, i),\n          announceIntervals[i]\n        )\n      }\n\n      unsubFns.forEach(async (didSub, i) => {\n        await didSub\n        queueAnnounce(await initPromises[i], i)\n      })\n    })\n\n    let onPeerConnect = noOp\n\n    occupiedRooms[appId] ||= {}\n\n    return (occupiedRooms[appId][roomId] = room(\n      f => (onPeerConnect = f),\n      id => delete connectedPeers[id],\n      () => {\n        delete occupiedRooms[appId][roomId]\n        announceTimeouts.forEach(clearTimeout)\n        unsubFns.forEach(async f => (await f)())\n        clearInterval(offerCleanupTimer)\n      }\n    ))\n  }\n}\n","import {decodeBytes, encodeBytes} from './utils.js'\n\nconst algo = 'AES-GCM'\nconst strToSha1 = {}\n\nconst pack = buff => btoa(String.fromCharCode.apply(null, new Uint8Array(buff)))\n\nconst unpack = packed => {\n  const str = atob(packed)\n\n  return new Uint8Array(str.length).map((_, i) => str.charCodeAt(i)).buffer\n}\n\nexport const sha1 = async str => {\n  if (strToSha1[str]) {\n    return strToSha1[str]\n  }\n\n  const hash = Array.from(\n    new Uint8Array(await crypto.subtle.digest('SHA-1', encodeBytes(str)))\n  )\n    .map(b => b.toString(36))\n    .join('')\n\n  // eslint-disable-next-line require-atomic-updates\n  strToSha1[str] = hash\n\n  return hash\n}\n\nexport const genKey = async (secret, appId, roomId) =>\n  crypto.subtle.importKey(\n    'raw',\n    await crypto.subtle.digest(\n      {name: 'SHA-256'},\n      encodeBytes(`${secret}:${appId}:${roomId}`)\n    ),\n    {name: algo},\n    false,\n    ['encrypt', 'decrypt']\n  )\n\nconst joinChar = '$'\nconst ivJoinChar = ','\n\nexport const encrypt = async (keyP, plaintext) => {\n  const iv = crypto.getRandomValues(new Uint8Array(16))\n\n  return (\n    iv.join(ivJoinChar) +\n    joinChar +\n    pack(\n      await crypto.subtle.encrypt(\n        {name: algo, iv},\n        await keyP,\n        encodeBytes(plaintext)\n      )\n    )\n  )\n}\n\nexport const decrypt = async (keyP, raw) => {\n  const [iv, c] = raw.split(joinChar)\n\n  return decodeBytes(\n    await crypto.subtle.decrypt(\n      {name: algo, iv: new Uint8Array(iv.split(ivJoinChar))},\n      await keyP,\n      unpack(c)\n    )\n  )\n}\n","export const libName = 'Trystero'\n\nexport const alloc = (n, f) => Array(n).fill().map(f)\n\nconst charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'\n\nexport const genId = n =>\n  alloc(n, () => charSet[Math.floor(Math.random() * charSet.length)]).join('')\n\nexport const selfId = genId(20)\n\nexport const all = Promise.all.bind(Promise)\n\nexport const isBrowser = typeof window !== 'undefined'\n\nexport const {entries, fromEntries, keys} = Object\n\nexport const noOp = () => {}\n\nexport const mkErr = msg => new Error(`${libName}: ${msg}`)\n\nconst encoder = new TextEncoder()\nconst decoder = new TextDecoder()\n\nexport const encodeBytes = txt => encoder.encode(txt)\n\nexport const decodeBytes = buffer => decoder.decode(buffer)\n\nexport const toHex = buffer =>\n  buffer.reduce((a, c) => a + c.toString(16).padStart(2, '0'), '')\n\nexport const topicPath = (...parts) => parts.join('@')\n\nexport const getRelays = (config, defaults, defaultN) =>\n  (config.relayUrls || defaults).slice(\n    0,\n    config.relayUrls\n      ? config.relayUrls.length\n      : config.relayRedundancy || defaultN\n  )\n\nexport const toJson = JSON.stringify\n\nexport const fromJson = JSON.parse\n\nconst defaultRetryMs = 3333\nconst socketRetryPeriods = {}\n\nexport const makeSocket = (url, onMessage) => {\n  const client = {}\n\n  const init = () => {\n    const socket = new WebSocket(url)\n\n    socket.onclose = () => {\n      socketRetryPeriods[url] ??= defaultRetryMs\n      setTimeout(init, socketRetryPeriods[url])\n      socketRetryPeriods[url] *= 2\n    }\n\n    socket.onmessage = e => onMessage(e.data)\n    client.socket = socket\n    client.url = socket.url\n    client.ready = new Promise(\n      res =>\n        (socket.onopen = () => {\n          res(client)\n          socketRetryPeriods[url] = defaultRetryMs\n        })\n    )\n    client.send = data => {\n      if (socket.readyState === 1) {\n        socket.send(data)\n      }\n    }\n  }\n\n  init()\n\n  return client\n}\n\nexport const socketGetter = clientMap => () =>\n  fromEntries(entries(clientMap).map(([url, client]) => [url, client.socket]))\n","import Peer from '@thaunknown/simple-peer'\nimport {alloc} from './utils.js'\n\nconst dataEvent = 'data'\nconst signalEvent = 'signal'\n\nexport default (initiator, config) => {\n  const peer = new Peer({\n    ...{iceServers: [{urls: defaultIceServers}]},\n    ...config,\n    initiator,\n    trickle: false\n  })\n  const onData = d => earlyDataBuffer.push(d)\n\n  let earlyDataBuffer = []\n\n  peer.on(dataEvent, onData)\n\n  return {\n    id: peer._id,\n\n    created: Date.now(),\n\n    connection: peer._pc,\n\n    get channel() {\n      return peer._channel\n    },\n\n    get isDead() {\n      return peer.destroyed\n    },\n\n    signal: sdp =>\n      new Promise(res => {\n        if (!initiator) {\n          peer.on(signalEvent, res)\n        }\n        peer.signal(sdp)\n      }),\n\n    sendData: data => peer.send(data),\n\n    destroy: () => peer.destroy(),\n\n    setHandlers: handlers =>\n      Object.entries(handlers).forEach(([event, fn]) => peer.on(event, fn)),\n\n    offerPromise: initiator\n      ? new Promise(res => peer.on(signalEvent, res))\n      : Promise.resolve(),\n\n    addStream: stream => peer.addStream(stream),\n\n    removeStream: stream => peer.removeStream(stream),\n\n    addTrack: (track, stream) => peer.addTrack(track, stream),\n\n    removeTrack: (track, stream) => peer.removeTrack(track, stream),\n\n    replaceTrack: (oldTrack, newTrack, stream) =>\n      peer.replaceTrack(oldTrack, newTrack, stream),\n\n    drainEarlyData: f => {\n      peer.off(dataEvent, onData)\n      earlyDataBuffer.forEach(f)\n      earlyDataBuffer = null\n    }\n  }\n}\n\nexport const defaultIceServers = [\n  ...alloc(5, (_, i) => `stun:stun${i || ''}.l.google.com:19302`),\n  'stun:global.stun.twilio.com:3478'\n]\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport Lite from './lite.js'\r\nimport errCode from 'err-code'\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Lite {\r\n  constructor (opts = {}) {\r\n    super(opts)\r\n    if (!this._pc) return\r\n\r\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\r\n    this._senderMap = new Map()\r\n\r\n    if (this.streams) {\r\n      this.streams.forEach(stream => {\r\n        this.addStream(stream)\r\n      })\r\n    }\r\n    this._pc.ontrack = event => {\r\n      this._onTrack(event)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a Transceiver to the connection.\r\n   * @param {String} kind\r\n   * @param {Object=} init\r\n   */\r\n  addTransceiver (kind, init) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addTransceiver()')\r\n\r\n    if (this.initiator) {\r\n      try {\r\n        this._pc.addTransceiver(kind, init)\r\n        this._needsNegotiation()\r\n      } catch (err) {\r\n        this.__destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))\r\n      }\r\n    } else {\r\n      this.emit('signal', { // request initiator to renegotiate\r\n        type: 'transceiverRequest',\r\n        transceiverRequest: { kind, init }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStream to the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  addStream (stream) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addStream()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.addTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Add a MediaStreamTrack to the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  addTrack (track, stream) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('addTrack()')\r\n\r\n    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\r\n    let sender = submap.get(stream)\r\n    if (!sender) {\r\n      sender = this._pc.addTrack(track, stream)\r\n      submap.set(stream, sender)\r\n      this._senderMap.set(track, submap)\r\n      this._needsNegotiation()\r\n    } else if (sender.removed) {\r\n      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')\r\n    } else {\r\n      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace a MediaStreamTrack by another in the connection.\r\n   * @param {MediaStreamTrack} oldTrack\r\n   * @param {MediaStreamTrack} newTrack\r\n   * @param {MediaStream} stream\r\n   */\r\n  replaceTrack (oldTrack, newTrack, stream) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('replaceTrack()')\r\n\r\n    const submap = this._senderMap.get(oldTrack)\r\n    const sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    if (newTrack) this._senderMap.set(newTrack, submap)\r\n\r\n    if (sender.replaceTrack != null) {\r\n      sender.replaceTrack(newTrack)\r\n    } else {\r\n      this.__destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStreamTrack from the connection.\r\n   * @param {MediaStreamTrack} track\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeTrack (track, stream) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('removeSender()')\r\n\r\n    const submap = this._senderMap.get(track)\r\n    const sender = submap ? submap.get(stream) : null\r\n    if (!sender) {\r\n      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')\r\n    }\r\n    try {\r\n      sender.removed = true\r\n      this._pc.removeTrack(sender)\r\n    } catch (err) {\r\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\r\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\r\n      } else {\r\n        this.__destroy(errCode(err, 'ERR_REMOVE_TRACK'))\r\n      }\r\n    }\r\n    this._needsNegotiation()\r\n  }\r\n\r\n  /**\r\n   * Remove a MediaStream from the connection.\r\n   * @param {MediaStream} stream\r\n   */\r\n  removeStream (stream) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._debug('removeSenders()')\r\n\r\n    stream.getTracks().forEach(track => {\r\n      this.removeTrack(track, stream)\r\n    })\r\n  }\r\n\r\n  _requestMissingTransceivers () {\r\n    if (this._pc.getTransceivers) {\r\n      this._pc.getTransceivers().forEach(transceiver => {\r\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\r\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\r\n          this.addTransceiver(transceiver.sender.track.kind)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  _onTrack (event) {\r\n    if (this.destroyed) return\r\n\r\n    event.streams.forEach(eventStream => {\r\n      this._debug('on track')\r\n      this.emit('track', event.track, eventStream)\r\n\r\n      this._remoteTracks.push({\r\n        track: event.track,\r\n        stream: eventStream\r\n      })\r\n\r\n      if (this._remoteStreams.some(remoteStream => {\r\n        return remoteStream.id === eventStream.id\r\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\r\n\r\n      this._remoteStreams.push(eventStream)\r\n      queueMicrotask(() => {\r\n        this._debug('on stream')\r\n        this.emit('stream', eventStream) // ensure all tracks have been added\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nexport default Peer\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(' ', ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","const { EventEmitter } = require('events')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst queueTick = require('queue-tick')\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst DISTURBED_STATUS = OPEN_STATUS | READ_RESUMED_READ_AHEAD | WRITE_QUEUED\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTick()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & DISTURBED_STATUS) !== OPENING\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isDisturbed,\n  isEnded,\n  isFinished,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","module.exports = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn)\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\n\nexport const encode = (arraybuffer: ArrayBuffer): string => {\n    let bytes = new Uint8Array(arraybuffer),\n        i,\n        len = bytes.length,\n        base64 = '';\n\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n\n    return base64;\n};\n\nexport const decode = (base64: string): ArrayBuffer => {\n    let bufferLength = base64.length * 0.75,\n        len = base64.length,\n        i,\n        p = 0,\n        encoded1,\n        encoded2,\n        encoded3,\n        encoded4;\n\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    const arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n};\n","import {\n  all,\n  alloc,\n  decodeBytes,\n  encodeBytes,\n  entries,\n  fromEntries,\n  fromJson,\n  isBrowser,\n  keys,\n  libName,\n  mkErr,\n  noOp,\n  toJson\n} from './utils.js'\n\nconst TypedArray = Object.getPrototypeOf(Uint8Array)\nconst typeByteLimit = 12\nconst typeIndex = 0\nconst nonceIndex = typeIndex + typeByteLimit\nconst tagIndex = nonceIndex + 1\nconst progressIndex = tagIndex + 1\nconst payloadIndex = progressIndex + 1\nconst chunkSize = 16 * 2 ** 10 - payloadIndex\nconst oneByteMax = 0xff\nconst buffLowEvent = 'bufferedamountlow'\nconst internalNs = ns => '@_' + ns\n\nexport default (onPeer, onPeerLeave, onSelfLeave) => {\n  const peerMap = {}\n  const actions = {}\n  const actionsCache = {}\n  const pendingTransmissions = {}\n  const pendingPongs = {}\n  const pendingStreamMetas = {}\n  const pendingTrackMetas = {}\n  const listeners = {\n    onPeerJoin: noOp,\n    onPeerLeave: noOp,\n    onPeerStream: noOp,\n    onPeerTrack: noOp\n  }\n\n  const iterate = (targets, f) =>\n    (targets\n      ? Array.isArray(targets)\n        ? targets\n        : [targets]\n      : keys(peerMap)\n    ).flatMap(id => {\n      const peer = peerMap[id]\n\n      if (!peer) {\n        console.warn(`${libName}: no peer with id ${id} found`)\n        return []\n      }\n\n      return f(id, peer)\n    })\n\n  const exitPeer = id => {\n    if (!peerMap[id]) {\n      return\n    }\n\n    delete peerMap[id]\n    delete pendingTransmissions[id]\n    delete pendingPongs[id]\n    listeners.onPeerLeave(id)\n    onPeerLeave(id)\n  }\n\n  const makeAction = type => {\n    if (actions[type]) {\n      return actionsCache[type]\n    }\n\n    if (!type) {\n      throw mkErr('action type argument is required')\n    }\n\n    const typeBytes = encodeBytes(type)\n\n    if (typeBytes.byteLength > typeByteLimit) {\n      throw mkErr(\n        `action type string \"${type}\" (${typeBytes.byteLength}b) exceeds ` +\n          `byte limit (${typeByteLimit}). Hint: choose a shorter name.`\n      )\n    }\n\n    const typeBytesPadded = new Uint8Array(typeByteLimit)\n    typeBytesPadded.set(typeBytes)\n\n    let nonce = 0\n\n    actions[type] = {\n      onComplete: noOp,\n      onProgress: noOp,\n\n      setOnComplete: f => (actions[type] = {...actions[type], onComplete: f}),\n\n      setOnProgress: f => (actions[type] = {...actions[type], onProgress: f}),\n\n      send: async (data, targets, meta, onProgress) => {\n        if (meta && typeof meta !== 'object') {\n          throw mkErr('action meta argument must be an object')\n        }\n\n        const dataType = typeof data\n\n        if (dataType === 'undefined') {\n          throw mkErr('action data cannot be undefined')\n        }\n\n        const isJson = dataType !== 'string'\n        const isBlob = data instanceof Blob\n        const isBinary =\n          isBlob || data instanceof ArrayBuffer || data instanceof TypedArray\n\n        if (meta && !isBinary) {\n          throw mkErr('action meta argument can only be used with binary data')\n        }\n\n        const buffer = isBinary\n          ? new Uint8Array(isBlob ? await data.arrayBuffer() : data)\n          : encodeBytes(isJson ? toJson(data) : data)\n\n        const metaEncoded = meta ? encodeBytes(toJson(meta)) : null\n\n        const chunkTotal =\n          Math.ceil(buffer.byteLength / chunkSize) + (meta ? 1 : 0) || 1\n\n        const chunks = alloc(chunkTotal, (_, i) => {\n          const isLast = i === chunkTotal - 1\n          const isMeta = meta && i === 0\n          const chunk = new Uint8Array(\n            payloadIndex +\n              (isMeta\n                ? metaEncoded.byteLength\n                : isLast\n                  ? buffer.byteLength -\n                    chunkSize * (chunkTotal - (meta ? 2 : 1))\n                  : chunkSize)\n          )\n\n          chunk.set(typeBytesPadded)\n          chunk.set([nonce], nonceIndex)\n          chunk.set(\n            [isLast | (isMeta << 1) | (isBinary << 2) | (isJson << 3)],\n            tagIndex\n          )\n          chunk.set(\n            [Math.round(((i + 1) / chunkTotal) * oneByteMax)],\n            progressIndex\n          )\n          chunk.set(\n            meta\n              ? isMeta\n                ? metaEncoded\n                : buffer.subarray((i - 1) * chunkSize, i * chunkSize)\n              : buffer.subarray(i * chunkSize, (i + 1) * chunkSize),\n            payloadIndex\n          )\n\n          return chunk\n        })\n\n        nonce = (nonce + 1) & oneByteMax\n\n        return all(\n          iterate(targets, async (id, peer) => {\n            const {channel} = peer\n            let chunkN = 0\n\n            while (chunkN < chunkTotal) {\n              const chunk = chunks[chunkN]\n\n              if (channel.bufferedAmount > channel.bufferedAmountLowThreshold) {\n                await new Promise(res => {\n                  const next = () => {\n                    channel.removeEventListener(buffLowEvent, next)\n                    res()\n                  }\n\n                  channel.addEventListener(buffLowEvent, next)\n                })\n              }\n\n              if (!peerMap[id]) {\n                break\n              }\n\n              peer.sendData(chunk)\n              chunkN++\n              onProgress?.(chunk[progressIndex] / oneByteMax, id, meta)\n            }\n          })\n        )\n      }\n    }\n\n    return (actionsCache[type] ||= [\n      actions[type].send,\n      actions[type].setOnComplete,\n      actions[type].setOnProgress\n    ])\n  }\n\n  const handleData = (id, data) => {\n    const buffer = new Uint8Array(data)\n    const type = decodeBytes(buffer.subarray(typeIndex, nonceIndex)).replaceAll(\n      '\\x00',\n      ''\n    )\n    const [nonce] = buffer.subarray(nonceIndex, tagIndex)\n    const [tag] = buffer.subarray(tagIndex, progressIndex)\n    const [progress] = buffer.subarray(progressIndex, payloadIndex)\n    const payload = buffer.subarray(payloadIndex)\n    const isLast = !!(tag & 1)\n    const isMeta = !!(tag & (1 << 1))\n    const isBinary = !!(tag & (1 << 2))\n    const isJson = !!(tag & (1 << 3))\n\n    if (!actions[type]) {\n      console.warn(\n        `${libName}: received message with unregistered type (${type})`\n      )\n      return\n    }\n\n    pendingTransmissions[id] ||= {}\n    pendingTransmissions[id][type] ||= {}\n\n    const target = (pendingTransmissions[id][type][nonce] ||= {chunks: []})\n\n    if (isMeta) {\n      target.meta = fromJson(decodeBytes(payload))\n    } else {\n      target.chunks.push(payload)\n    }\n\n    actions[type].onProgress(progress / oneByteMax, id, target.meta)\n\n    if (!isLast) {\n      return\n    }\n\n    const full = new Uint8Array(\n      target.chunks.reduce((a, c) => a + c.byteLength, 0)\n    )\n\n    target.chunks.reduce((a, c) => {\n      full.set(c, a)\n      return a + c.byteLength\n    }, 0)\n\n    delete pendingTransmissions[id][type][nonce]\n\n    if (isBinary) {\n      actions[type].onComplete(full, id, target.meta)\n    } else {\n      const text = decodeBytes(full)\n      actions[type].onComplete(isJson ? fromJson(text) : text, id)\n    }\n  }\n\n  const leave = async () => {\n    await sendLeave('')\n    await new Promise(res => setTimeout(res, 99))\n    entries(peerMap).forEach(([id, peer]) => {\n      peer.destroy()\n      delete peerMap[id]\n    })\n    onSelfLeave()\n  }\n\n  const [sendPing, getPing] = makeAction(internalNs('ping'))\n  const [sendPong, getPong] = makeAction(internalNs('pong'))\n  const [sendSignal, getSignal] = makeAction(internalNs('signal'))\n  const [sendStreamMeta, getStreamMeta] = makeAction(internalNs('stream'))\n  const [sendTrackMeta, getTrackMeta] = makeAction(internalNs('track'))\n  const [sendLeave, getLeave] = makeAction(internalNs('leave'))\n\n  onPeer((peer, id) => {\n    if (peerMap[id]) {\n      return\n    }\n\n    peerMap[id] = peer\n\n    peer.setHandlers({\n      data: d => handleData(id, d),\n      stream: stream => {\n        listeners.onPeerStream(stream, id, pendingStreamMetas[id])\n        delete pendingStreamMetas[id]\n      },\n      track: (track, stream) => {\n        listeners.onPeerTrack(track, stream, id, pendingTrackMetas[id])\n        delete pendingTrackMetas[id]\n      },\n      signal: sdp => sendSignal(sdp, id),\n      close: () => exitPeer(id),\n      error: () => exitPeer(id)\n    })\n\n    listeners.onPeerJoin(id)\n    peer.drainEarlyData?.(d => handleData(id, d))\n  })\n\n  getPing((_, id) => sendPong('', id))\n\n  getPong((_, id) => {\n    pendingPongs[id]?.()\n    delete pendingPongs[id]\n  })\n\n  getSignal((sdp, id) => peerMap[id]?.signal(sdp))\n\n  getStreamMeta((meta, id) => (pendingStreamMetas[id] = meta))\n\n  getTrackMeta((meta, id) => (pendingTrackMetas[id] = meta))\n\n  getLeave((_, id) => exitPeer(id))\n\n  if (isBrowser) {\n    addEventListener('beforeunload', leave)\n  }\n\n  return {\n    makeAction,\n\n    leave,\n\n    ping: async id => {\n      if (!id) {\n        throw mkErr('ping() must be called with target peer ID')\n      }\n\n      const start = Date.now()\n\n      sendPing('', id)\n      await new Promise(res => (pendingPongs[id] = res))\n      return Date.now() - start\n    },\n\n    getPeers: () =>\n      fromEntries(entries(peerMap).map(([id, peer]) => [id, peer.connection])),\n\n    addStream: (stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendStreamMeta(meta, id)\n        }\n\n        peer.addStream(stream)\n      }),\n\n    removeStream: (stream, targets) =>\n      iterate(targets, (_, peer) => peer.removeStream(stream)),\n\n    addTrack: (track, stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.addTrack(track, stream)\n      }),\n\n    removeTrack: (track, stream, targets) =>\n      iterate(targets, (_, peer) => peer.removeTrack(track, stream)),\n\n    replaceTrack: (oldTrack, newTrack, stream, targets, meta) =>\n      iterate(targets, async (id, peer) => {\n        if (meta) {\n          await sendTrackMeta(meta, id)\n        }\n\n        peer.replaceTrack(oldTrack, newTrack, stream)\n      }),\n\n    onPeerJoin: f => (listeners.onPeerJoin = f),\n\n    onPeerLeave: f => (listeners.onPeerLeave = f),\n\n    onPeerStream: f => (listeners.onPeerStream = f),\n\n    onPeerTrack: f => (listeners.onPeerTrack = f)\n  }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","joinRoom","$a8ede964070fd1a8$export$767472c72ffc2784","$7vd9o","$eLZBv","$cQlYm","$a8ede964070fd1a8$var$clients","$a8ede964070fd1a8$var$eventMsgType","$a8ede964070fd1a8$var$privateKey","isBrowser","schnorr","utils","randomPrivateKey","$a8ede964070fd1a8$var$publicKey","toHex","getPublicKey","$a8ede964070fd1a8$var$subIdToTopic","$a8ede964070fd1a8$var$msgHandlers","$a8ede964070fd1a8$var$now","Math","floor","Date","now","$a8ede964070fd1a8$var$createEvent","topic","content","payload","kind","pubkey","created_at","tags","id","Uint8Array","crypto","subtle","digest","encodeBytes","toJson","sig","sign","$a8ede964070fd1a8$var$subscribe","subId","kinds","since","$a8ede964070fd1a8$var$unsubscribe","init","config","getRelays","$a8ede964070fd1a8$export$2e74fe4648f5c212","map","url","client","makeSocket","data","msgType","relayMsg","fromJson","prefix","libName","console","warn","ready","subscribe","rootTopic","selfTopic","onMessage","rootSubId","genId","selfSubId","peerTopic","signal","send","announce","peerId","selfId","socketGetter","value","encodeToCurve","hashToCurve","secp256k1","$5x5A6","$9YMwy","$2kyNN","$57dpp","$i945l","$1GzxI","$7lNi7","$5765a1182d26d576$var$secp256k1P","BigInt","$5765a1182d26d576$var$secp256k1N","$5765a1182d26d576$var$_1n","$5765a1182d26d576$var$_2n","$5765a1182d26d576$var$divNearest","b","$5765a1182d26d576$var$sqrtMod","y","_3n","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","root","$5765a1182d26d576$var$Fpk1","eql","sqr","Error","Field","undefined","sqrt","createCurve","Fp","Gx","Gy","h","lowS","endo","beta","splitScalar","k","a1","b1","a2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","sha256","$5765a1182d26d576$var$_0n","$5765a1182d26d576$var$TAGGED_HASH_PREFIXES","$5765a1182d26d576$var$taggedHash","tag","messages","tagP","tagH","from","c","charCodeAt","concatBytes","$5765a1182d26d576$var$pointToBytes","point","toRawBytes","slice","$5765a1182d26d576$var$numTo32b","numberToBytesBE","$5765a1182d26d576$var$modP","x","$5765a1182d26d576$var$modN","$5765a1182d26d576$var$Point","ProjectivePoint","$5765a1182d26d576$var$GmulAdd","Q","BASE","multiplyAndAddUnsafe","$5765a1182d26d576$var$schnorrGetExtPubKey","priv","d_","normPrivateKeyToScalar","p","fromPrivateKey","scalar","hasEvenY","bytes","$5765a1182d26d576$var$lift_x","aInRange","xx","assertValidity","$5765a1182d26d576$var$num","bytesToNumberBE","$5765a1182d26d576$var$challenge","args","$5765a1182d26d576$var$schnorrVerify","signature","message","publicKey","ensureBytes","m","pub","P","r","subarray","inRange","R","toAffine","error","privateKey","auxRand","randomBytes","px","d","t","k_","rx","verify","lift_x","pointToBytes","taggedHash","$5765a1182d26d576$var$isoMap","isogenyMap","i","j","$5765a1182d26d576$var$mapSWU","mapToCurveSimpleSWU","A","B","Z","create","$5765a1182d26d576$var$htf","createHasher","scalars","DST","encodeDST","ORDER","expand","hash","sha224","SHA256","$jC5k4","$40745d2159d0279c$var$SHA256_K","Uint32Array","$40745d2159d0279c$var$SHA256_IV","$40745d2159d0279c$var$SHA256_W","$40745d2159d0279c$var$SHA256","HashMD","constructor","C","D","E","F","G","H","process","view","offset","getUint32","W15","W2","s0","rotr","s1","T1","Chi","T2","sigma0","Maj","roundClean","fill","destroy","buffer","$40745d2159d0279c$var$SHA224","outputLen","wrapConstructor","$1BNC9","$e475b1ec6dc1b20c$var$HashMD","Hash","blockLen","padOffset","isLE","finished","length","pos","destroyed","createView","update","aexists","len","toBytes","take","min","dataView","digestInto","out","aoutput","$e475b1ec6dc1b20c$var$setBigUint64","byteOffset","setBigUint64","_32n","_u32_max","wh","Number","wl","l","setUint32","oview","outLen","state","res","_cloneInto","to","$12bfbb86ba5aff13$var$anumber","isSafeInteger","$12bfbb86ba5aff13$var$abytes","lengths","ArrayBuffer","isView","name","includes","$12bfbb86ba5aff13$var$ahash","$12bfbb86ba5aff13$var$aexists","instance","checkFinished","$12bfbb86ba5aff13$var$aoutput","anumber","number","abytes","ahash","exists","output","nextTick","byteSwapIfBE","byteSwap","rotl","u32","u8","isBytes","byteSwap32","arr","bytesToHex","hex","$743f5b81a9da9842$var$hexes","hexToBytes","hl","al","array","ai","hi","n1","$743f5b81a9da9842$var$asciiToBase16","n2","asyncLoop","$743f5b81a9da9842$var$asyncLoop","utf8ToBytes","$743f5b81a9da9842$var$utf8ToBytes","$743f5b81a9da9842$var$toBytes","arrays","sum","pad","checkOpts","defaults","opts","toString","call","assign","hashCons","hashC","msg","tmp","wrapConstructorWithOpts","wrapXOFConstructorWithOpts","bytesLength","$g35Du","getRandomValues","byteLength","DataView","word","shift","Array","_","padStart","$743f5b81a9da9842$var$asciis","_0","_9","f","ch","$743f5b81a9da9842$var$nextTick","iters","tick","cb","ts","diff","str","TextEncoder","encode","clone","getHash","$1b2871fdba5348e8$var$getHash","curveDef","defHash","weierstrass","freeze","$cLviI","hmac","key","msgs","HMAC","$94b2278aec7365b2$var$HMAC","_key","iHash","oHash","buf","getPrototypeOf","DER","weierstrassPoints","$55a0bac5c8bffc9a$var$weierstrassPoints","CURVE","$55a0bac5c8bffc9a$var$validateOpts","curve","$kswOL","validateBasic","validateObject","bits2int","bits2int_modN","CURVE_ORDER","compressedLen","BYTES","uncompressedLen","modN","invN","invert","Point","weierstrassEquation","isWithinCurveOrder","_c","isCompressed","cat","abool","fromBytes","head","tail","$55a0bac5c8bffc9a$var$_1n","y2","sqrtError","neg","numToNByteStr","num","nByteLength","slcNum","Signature","recovery","fromCompact","fromDER","toSig","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","fromHex","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","hexFromSig","toCompactRawBytes","toCompactHex","isProbPub","item","delta","nBitLength","ORDER_MASK","bitMask","int2octets","$55a0bac5c8bffc9a$var$_0n","defaultSigOpts","prehash","defaultVerOpts","_setWindowSize","getSharedSecret","privateA","publicB","multiply","privKey","seed","k2sig","prepSig","some","extraEntropy","ent","$55a0bac5c8bffc9a$var$validateSigVerOpts","h1int","seedArgs","push","kBytes","ik","q","normS","isBiggerThanHalfOrder","drbg","createHmacDrbg","_sig","format","isHex","isObj","sg","derError","Err","is","isValidPrivateKey","getMinHashLength","mapHashToField","precompute","windowSize","SWUFpSqrtRatio","$55a0bac5c8bffc9a$var$SWUFpSqrtRatio","validateField","isValid","sqrtRatio","isOdd","u","tv1","tv2","tv3","tv4","tv5","tv6","mul","add","ONE","cmov","ZERO","e1","div","$55a0bac5c8bffc9a$var$b2n","$55a0bac5c8bffc9a$var$h2b","_tlv","dataLen","numberToHexUnpadded","lenLen","decode","first","lengthBytes","_int","parseInt","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","rs","ss","$55a0bac5c8bffc9a$var$_2n","$55a0bac5c8bffc9a$var$_3n","$55a0bac5c8bffc9a$var$_4n","$55a0bac5c8bffc9a$var$validatePointOpts","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","Fn","_isCompressed","x2","x3","N","assertPrjPoint","other","toAffineMemo","memoized","iz","py","pz","z","is0","inv","ax","ay","zz","assertValidMemo","left","right","fromAffine","normalizeZ","points","toInv","invertBatch","msm","pippenger","wnaf","setWindowSize","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","X3","Y3","Z3","t0","t3","sub","t4","t5","subtract","wNAF","wNAFCached","multiplyUnsafe","sc","I","hasPrecomputes","wNAFCachedUnsafe","k1p","k2p","fake","f1p","f2p","constTimeNegate","cofactor","_bits","ceil","o","_2n_pow_c1_1","_2n_pow_c1","c3","c4","c6","pow","c7","isQR","tvv5","y1","bits","elm","getW","unsafeLadder","_0n","_1n","precomputeWindow","W","windows","calcWOpts","base","precomputes","mask","maxNumber","shiftBy","wbits","offset2","abs","cond1","cond2","wNAFUnsafe","acc","curr","getPrecomputes","transform","comp","pointPrecomputes","prev","validateW","pointWindowSizes","delete","fieldN","validateMSMPoints","validateMSMScalars","zero","bitLen","MASK","buckets","lastBits","BITS","resI","sumI","precomputeMSMUnsafe","tableSize","chunks","tables","nLength","condition","isArray","forEach","field","WeakMap","isNegativeLE","$d35c3c82524fc7f9$var$mod","$d35c3c82524fc7f9$var$pow","power","modulo","$d35c3c82524fc7f9$var$_0n","$d35c3c82524fc7f9$var$invert","tonelliShanks","$d35c3c82524fc7f9$var$tonelliShanks","FpSqrt","$d35c3c82524fc7f9$var$FpSqrt","$d35c3c82524fc7f9$var$FIELD_FIELDS","reduce","val","FpPow","$d35c3c82524fc7f9$var$FpPow","FpInvertBatch","$d35c3c82524fc7f9$var$FpInvertBatch","FpDiv","lhs","rhs","FpLegendre","$d35c3c82524fc7f9$var$FpLegendre","FpIsSquare","legendre","$d35c3c82524fc7f9$var$nLength","redef","sqrtP","$d35c3c82524fc7f9$var$_1n","sqrN","addN","subN","mulN","lst","numberToBytesLE","bytesToNumberLE","FpSqrtOdd","FpSqrtEven","hashToPrivateScalar","groupOrder","hashLen","minLen","getFieldBytesLength","$d35c3c82524fc7f9$var$getFieldBytesLength","$d35c3c82524fc7f9$var$getMinHashLength","fieldOrder","fieldLen","reduced","$d35c3c82524fc7f9$var$_2n","$d35c3c82524fc7f9$var$_3n","$d35c3c82524fc7f9$var$_4n","$d35c3c82524fc7f9$var$_5n","$d35c3c82524fc7f9$var$_8n","result","gcd","S","legendreC","p1div4","Q1div2","g","ge","nv","nums","lastMultiplied","inverted","reduceRight","order","legendreConst","_nBitLength","bitLength","notImplemented","$13a548bfcdef076f$var$isBytes","$13a548bfcdef076f$var$abytes","title","$13a548bfcdef076f$var$bytesToHex","$13a548bfcdef076f$var$numberToHexUnpadded","hexToNumber","$13a548bfcdef076f$var$hexToNumber","$13a548bfcdef076f$var$hexToBytes","reverse","$13a548bfcdef076f$var$numberToBytesBE","numberToVarBytesBE","expectedLength","$13a548bfcdef076f$var$concatBytes","equalBytes","$13a548bfcdef076f$var$inRange","max","$13a548bfcdef076f$var$_0n","$13a548bfcdef076f$var$_1n","bitGet","bitSet","qByteLen","hmacFn","$13a548bfcdef076f$var$u8n","reset","reseed","$13a548bfcdef076f$var$u8fr","gen","sl","pred","object","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","$13a548bfcdef076f$var$validatorFns","String","entries","fn","arg","computed","$13a548bfcdef076f$var$_2n","$13a548bfcdef076f$var$hexes","$13a548bfcdef076f$var$asciis","$13a548bfcdef076f$var$asciiToBase16","$13a548bfcdef076f$var$isPosBig","bigint","function","boolean","string","stringOrUint8Array","expand_message_xmd","$3b9801ed630d510a$var$expand_message_xmd","expand_message_xof","$3b9801ed630d510a$var$expand_message_xof","hash_to_field","$3b9801ed630d510a$var$hash_to_field","COEFF","xNum","xDen","yNum","yDen","mapToCurve","def","options","u0","$3b9801ed630d510a$var$os2ip","$3b9801ed630d510a$var$i2osp","$3b9801ed630d510a$var$anum","lenInBytes","b_in_bytes","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","$3b9801ed630d510a$var$strxor","pseudo_random_bytes","dkLen","count","prb","_DST","L","log2p","len_in_bytes","elm_offset","tv","$ac153db803e0260e$export$2e2bcd8739ae039","$lnAYI","$ZfjYC","$dZ1ej","initPromises","offerPool","offerCleanupTimer","occupiedRooms","didInit","roomId","onJoinError","appId","pendingOffers","connectedPeers","rootTopicPlaintext","topicPath","rootTopicP","sha1","selfTopicP","genKey","password","withKey","sdp","toPlain","decrypt","toCipher","encrypt","makeOffer","rtcConfig","connectPeer","peer","clientId","onPeerConnect","disconnectPeer","prunePendingOffer","offer","getOffers","alloc","all","splice","offerPromise","then","handleJoinError","sdpType","handleMessage","signalPeer","answer","plainOffer","myOffer","setHandlers","connect","close","isDead","plainAnswer","setTimeout","announceIntervals","mkErr","firebaseApp","initRes","setInterval","filter","shouldLive","created","$ac153db803e0260e$var$offerTtl","announceTimeouts","unsubFns","clientP","queueAnnounce","ms","didSub","noOp","clearTimeout","clearInterval","$f9086e0cc03499bb$export$5091bdda49ba90f5","$f9086e0cc03499bb$export$ceb27d5ba53e5cf8","$f9086e0cc03499bb$export$5b0f6292f11d1d18","$f9086e0cc03499bb$export$e85a0c9a1067c5d3","$f9086e0cc03499bb$var$algo","$f9086e0cc03499bb$var$strToSha1","$f9086e0cc03499bb$var$pack","buff","btoa","fromCharCode","apply","$f9086e0cc03499bb$var$unpack","packed","atob","join","secret","importKey","keyP","plaintext","iv","raw","split","decodeBytes","$959b62a819adc0d1$export$cc42576d343e0f6a","$959b62a819adc0d1$export$2de70f21292aac9e","$959b62a819adc0d1$export$87d45d9755ebb726","$959b62a819adc0d1$export$d01767fa86c38c2d","$959b62a819adc0d1$export$84bf76cd7afc7469","$959b62a819adc0d1$export$4e09c449d6c407f7","$959b62a819adc0d1$export$3e9f948b41964866","$959b62a819adc0d1$export$5150077fc2e7c662","$959b62a819adc0d1$export$ed97f33186d4b816","$959b62a819adc0d1$export$b50b6e108474309b","$959b62a819adc0d1$export$5575a5c000f2af79","$959b62a819adc0d1$export$2589e87d78677b0d","$959b62a819adc0d1$export$c97600adfa527f5b","$959b62a819adc0d1$export$7ea66e3774a60b67","$959b62a819adc0d1$export$54013e572e6e896e","$959b62a819adc0d1$export$37be945df5c81949","$959b62a819adc0d1$export$d5b7a8bf56ee1fe2","$959b62a819adc0d1$export$7ae2d2a8b28a8cb8","$959b62a819adc0d1$export$62e26c4935767b5d","$959b62a819adc0d1$export$2f8cc4ea4a8a734","$959b62a819adc0d1$var$charSet","random","Promise","bind","fromEntries","keys","$959b62a819adc0d1$var$encoder","$959b62a819adc0d1$var$decoder","TextDecoder","txt","parts","defaultN","relayUrls","relayRedundancy","JSON","stringify","parse","$959b62a819adc0d1$var$socketRetryPeriods","socket","WebSocket","onclose","onmessage","onopen","readyState","clientMap","$0b819517a10e476a$export$2e2bcd8739ae039","$5Y6Yt","$0b819517a10e476a$var$dataEvent","$0b819517a10e476a$var$signalEvent","initiator","iceServers","urls","$0b819517a10e476a$export$35d65ce76511c412","trickle","onData","earlyDataBuffer","on","_id","connection","_pc","channel","_channel","sendData","handlers","event","resolve","addStream","stream","removeStream","addTrack","track","removeTrack","replaceTrack","oldTrack","newTrack","drainEarlyData","off","$4587f751384f4696$export$2e2bcd8739ae039","$2MBfS","$6mAaY","$4587f751384f4696$var$Peer","streams","_senderMap","Map","ontrack","_onTrack","addTransceiver","_destroying","_debug","_needsNegotiation","err","__destroy","emit","transceiverRequest","getTracks","submap","sender","removed","_sendersAwaitingStable","_requestMissingTransceivers","getTransceivers","transceiver","mid","requested","eventStream","_remoteTracks","_remoteStreams","remoteStream","queueMicrotask","$206cf6902e689423$export$2e2bcd8739ae039","$5tDV0","$e6IBz","$kSdTa","$4aZbe","$206cf6902e689423$var$Debug","$206cf6902e689423$var$filterTrickle","replace","$206cf6902e689423$var$Peer","Duplex","allowHalfOpen","__objectMode","objectMode","arr2hex","channelName","channelConfig","channelNegotiated","negotiated","offerOptions","answerOptions","sdpTransform","allowHalfTrickle","iceCompleteTimeout","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","RTCPeerConnection","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_closingInterval","_chunk","_cb","_interval","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","_onIceCandidate","peerIdentity","catch","_setupData","createDataChannel","ondatachannel","_onFinishBound","_onFinish","once","bufferSize","bufferedAmount","connected","address","port","family","renegotiate","candidate","remoteDescription","_addIceCandidate","setRemoteDescription","RTCSessionDescription","_createAnswer","iceCandidateObj","RTCIceCandidate","addIceCandidate","endsWith","chunk","negotiate","_createOffer","_final","_readableState","ended","end","_destroy","removeListener","onerror","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","filename","lineno","colno","isClosing","_write","destroySoon","_startIceCompleteTimeout","createOffer","sendOffer","localDescription","setLocalDescription","createAnswer","sendAnswer","connectionState","iceConnectionState","iceGatheringState","_maybeReady","getStats","flattenValues","report","prototype","values","reports","names","stat","timestamp","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","ipAddress","portNumber","googLocalAddress","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","_onInterval","unref","signalingState","sdpMLineIndex","sdpMid","text2arr","arguments","WEBRTC_SUPPORT","sdpSemantics","warned","$6qd2L","formatArgs","useColors","namespace","humanize","color","index","lastC","match","save","namespaces","storage","setItem","removeItem","load","getItem","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","localstorage","localStorage","colors","log","debug","formatters","$4acf49f6c3e67aec$var$cachedSetTimeout","$4acf49f6c3e67aec$var$cachedClearTimeout","$4acf49f6c3e67aec$var$currentQueue","$4acf49f6c3e67aec$var$process","$4acf49f6c3e67aec$var$defaultSetTimout","$4acf49f6c3e67aec$var$defaultClearTimeout","$4acf49f6c3e67aec$var$runTimeout","fun","$4acf49f6c3e67aec$var$queue","$4acf49f6c3e67aec$var$draining","$4acf49f6c3e67aec$var$queueIndex","$4acf49f6c3e67aec$var$cleanUpNextTick","concat","$4acf49f6c3e67aec$var$drainQueue","timeout","run","$4acf49f6c3e67aec$var$runClearTimeout","marker","$4acf49f6c3e67aec$var$Item","$4acf49f6c3e67aec$var$noop","browser","env","argv","version","versions","addListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","enabled","coerce","unshift","formatter","logFn","selectColor","extend","delimiter","newDebug","matchesTemplate","search","template","searchIndex","templateIndex","starIndex","matchIndex","stack","disable","skips","enable","ns","trim","Boolean","skip","$5c000934e2440d9a$var$plural","msAbs","round","isPlural","$5c000934e2440d9a$var$parse","exec","parseFloat","$5c000934e2440d9a$var$d","$5c000934e2440d9a$var$h","$5c000934e2440d9a$var$m","$5c000934e2440d9a$var$s","isFinite","long","$a45439d68055962e$export$c09fccd4ad34d599","$a45439d68055962e$export$de588b9e6d2bdb13","$a45439d68055962e$export$a7466b614c6b30d0","$a45439d68055962e$var$scope","mozRTCPeerConnection","webkitRTCPeerConnection","mozRTCSessionDescription","webkitRTCSessionDescription","mozRTCIceCandidate","webkitRTCIceCandidate","RTCIceTransport","RTCDataChannel","RTCSctpTransport","RTCDtlsTransport","RTCCertificate","MediaStream","MediaStreamTrack","MediaStreamTrackEvent","RTCPeerConnectionIceEvent","RTCDataChannelEvent","RTCTrackEvent","RTCError","RTCErrorEvent","RTCRtpTransceiver","RTCRtpReceiver","RTCRtpSender","$f3239fcb9523168b$require$EventEmitter","$dG33B","EventEmitter","$f3239fcb9523168b$var$STREAM_DESTROYED","$f3239fcb9523168b$var$PREMATURE_CLOSE","$lb7s4","$8KR6e","$dwlN4","$f3239fcb9523168b$var$asyncIterator","Symbol","asyncIterator","$f3239fcb9523168b$var$WritableState","highWaterMark","mapWritable","byteLengthWritable","queue","buffered","pipeline","drains","$f3239fcb9523168b$var$defaultByteLength","afterWrite","$f3239fcb9523168b$var$afterWrite","afterUpdateNextTick","$f3239fcb9523168b$var$updateWriteNT","_duplexState","$f3239fcb9523168b$var$WRITE_FINISHING","$f3239fcb9523168b$var$WRITE_QUEUED","$f3239fcb9523168b$var$MAX","autoBatch","$f3239fcb9523168b$var$OPEN_STATUS","_writableState","$f3239fcb9523168b$var$DESTROY_STATUS","_writev","$f3239fcb9523168b$var$WRITE_ACTIVE","$f3239fcb9523168b$var$WRITE_PRIMARY","updateNonPrimary","continueUpdate","$f3239fcb9523168b$var$afterFinal","$f3239fcb9523168b$var$DESTROYING","$f3239fcb9523168b$var$WRITE_NEXT_TICK","$f3239fcb9523168b$var$READ_ACTIVE","$f3239fcb9523168b$var$afterDestroy","_open","$f3239fcb9523168b$var$afterOpen","updateCallback","$f3239fcb9523168b$var$WRITE_UPDATING","updateNextTick","$f3239fcb9523168b$var$ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","$f3239fcb9523168b$var$afterRead","$f3239fcb9523168b$var$updateReadNT","pipe","$f3239fcb9523168b$var$Pipeline","$f3239fcb9523168b$var$noop","$f3239fcb9523168b$var$isStreamx","done","$f3239fcb9523168b$var$afterDrain","pending","read","write","drain","$f3239fcb9523168b$var$READ_RESUMED","_read","$f3239fcb9523168b$var$READ_EMIT_READABLE","$f3239fcb9523168b$var$READ_PRIMARY","$f3239fcb9523168b$var$READ_DONE","$f3239fcb9523168b$var$READ_UPDATING","$f3239fcb9523168b$var$TransformState","afterTransform","$f3239fcb9523168b$var$afterTransform","afterFinal","src","dst","afterPipe","pipeToFinished","ws","$f3239fcb9523168b$var$tickDrains","writes","$f3239fcb9523168b$var$newListener","$f3239fcb9523168b$var$READ_EMIT_DATA","$f3239fcb9523168b$var$Stream","open","predestroy","_predestroy","addEventListener","$f3239fcb9523168b$var$abort","readable","writable","destroying","$f3239fcb9523168b$var$WRITE_NON_PRIMARY","$f3239fcb9523168b$var$Readable","$f3239fcb9523168b$var$OPENING","eagerOpen","encoding","setEncoding","dec","$f3239fcb9523168b$var$echo","next","remaining","dest","resume","pause","_fromAsyncIterator","ite","return","isBackpressured","isPaused","promiseResolve","promiseReject","ondata","reject","throw","$f3239fcb9523168b$var$Writable","writev","final","cork","uncork","batch","$f3239fcb9523168b$var$WRITE_UNDRAINED","drained","$f3239fcb9523168b$var$isWritev","$f3239fcb9523168b$var$Duplex","$f3239fcb9523168b$var$Transform","_transformState","_transform","flush","_flush","$f3239fcb9523168b$var$transformAfterFlush","$f3239fcb9523168b$var$pipeline","pop","errorHandle","rd","wr","fin","autoDestroy","$f3239fcb9523168b$var$isStream","$f3239fcb9523168b$var$isTypedArray","pipelinePromise","isStream","isStreamx","isDisturbed","isEnded","isFinished","getStreamError","Stream","Writable","Readable","Transform","PassThrough","$9f5191ad6e142a03$var$ReflectOwnKeys","$9f5191ad6e142a03$var$R","Reflect","$9f5191ad6e142a03$var$ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","$9f5191ad6e142a03$var$NumberIsNaN","isNaN","$9f5191ad6e142a03$var$EventEmitter","emitter","flags","errorListener","resolver","$9f5191ad6e142a03$var$eventTargetAgnosticAddListener","_events","_eventsCount","_maxListeners","$9f5191ad6e142a03$var$defaultMaxListeners","$9f5191ad6e142a03$var$checkListener","listener","TypeError","$9f5191ad6e142a03$var$_getMaxListeners","that","defaultMaxListeners","$9f5191ad6e142a03$var$_addListener","prepend","events","newListener","existing","w","$9f5191ad6e142a03$var$onceWrapper","fired","wrapFn","$9f5191ad6e142a03$var$_onceWrap","wrapped","$9f5191ad6e142a03$var$_listeners","unwrap","evlistener","$9f5191ad6e142a03$var$unwrapListeners","ret","$9f5191ad6e142a03$var$arrayClone","$9f5191ad6e142a03$var$listenerCount","copy","wrapListener","removeEventListener","RangeError","setMaxListeners","getMaxListeners","doError","er","context","handler","list","position","originalListener","$9f5191ad6e142a03$var$spliceOne","rawListeners","listenerCount","eventNames","$fD4LP","hwm","clear","peek","isEmpty","top","btm","last","$j8dkl","$9d7f2aa139d703c2$var$normalizeEncoding","decoder","$4a20dbf5fa201e08$var$assign","obj","props","code","ErrClass","$30a78db839b82430$export$5ef417313c99c2ea","$30a78db839b82430$export$5f828d93ff035aa8","$3bdLe","$30a78db839b82430$var$encoder","$30a78db839b82430$var$scope","$30a78db839b82430$var$crypto","msCrypto","webkitSubtle","size","$250d12c4048d99a7$export$1b9ece1fd5efdcd7","$250d12c4048d99a7$export$70d45ef99b984e19","$250d12c4048d99a7$export$30a0448ba3664bd6","$250d12c4048d99a7$var$encodeLookup","$250d12c4048d99a7$var$decodeLookup","sizeof","$6e4a09eefdefdb9a$export$c564cdbbe6da493","$6e4a09eefdefdb9a$export$2f872c0f2117be69","$6e4a09eefdefdb9a$var$chars","$6e4a09eefdefdb9a$var$lookup","$6e4a09eefdefdb9a$var$i","arraybuffer","base64","substring","encoded1","encoded2","encoded3","encoded4","bufferLength","$a2e1ed1997be3b3c$export$2e2bcd8739ae039","$a2e1ed1997be3b3c$var$TypedArray","$a2e1ed1997be3b3c$var$buffLowEvent","$a2e1ed1997be3b3c$var$internalNs","onPeer","onPeerLeave","onSelfLeave","peerMap","actions","actionsCache","pendingTransmissions","pendingPongs","pendingStreamMetas","pendingTrackMetas","onPeerJoin","onPeerStream","onPeerTrack","iterate","targets","flatMap","exitPeer","makeAction","typeBytes","typeBytesPadded","nonce","onComplete","onProgress","setOnComplete","setOnProgress","meta","dataType","isJson","isBlob","Blob","isBinary","arrayBuffer","metaEncoded","chunkTotal","isLast","isMeta","$a2e1ed1997be3b3c$var$payloadIndex","$a2e1ed1997be3b3c$var$progressIndex","$a2e1ed1997be3b3c$var$chunkSize","$a2e1ed1997be3b3c$var$typeIndex","$a2e1ed1997be3b3c$var$nonceIndex","$a2e1ed1997be3b3c$var$tagIndex","chunkN","handleData","replaceAll","progress","full","text","leave","sendLeave","sendPing","getPing","sendPong","getPong","sendSignal","getSignal","sendStreamMeta","getStreamMeta","sendTrackMeta","getTrackMeta","getLeave","ping","start","getPeers"],"version":3,"file":"trystero.4f19cd1f.js.map"}